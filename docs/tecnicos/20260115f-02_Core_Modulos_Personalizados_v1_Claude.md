
ESPECIFICACIÓN DE
MÓDULOS PERSONALIZADOS

Arquitectura de Módulos Custom Drupal 11

JARABA IMPACT PLATFORM
Documento Técnico de Implementación

Versión:	1.0
Fecha:	Enero 2026
Estado:	Documento Técnico Definitivo
 
Tabla de Contenidos
Tabla de Contenidos	1
1. Arquitectura de Módulos	1
1.1 Mapa de Módulos	1
1.2 Diagrama de Dependencias	1
2. Módulo: jaraba_core	1
2.1 Estructura de Archivos	1
2.2 Servicios Principales	1
2.2.1 ConfigurationService	1
2.2.2 TrazabilidadService	1
3. Módulo: jaraba_tenant	1
3.1 TenantContextService	1
3.2 Query Alter Hook	1
4. Módulo: jaraba_stripe	1
4.1 StripeConnectService	1
4.2 Webhook Handler	1
5. Módulo: jaraba_foc_metrics	1
5.1 MetricsCalculationService	1
5.2 Batch Processor	1
6. Módulo: jaraba_diagnostic	1
6.1 DiagnosticEngineService	1
6.2 Integración ECA	1
7. Módulo: jaraba_webhooks	1
7.1 Eventos Disponibles	1
7.2 WebhookDispatcherService	1
8. Registro de Servicios	1
9. Roadmap de Implementación	1

 
1. Arquitectura de Módulos
La plataforma Jaraba Impact se construye sobre una arquitectura modular que separa responsabilidades en módulos custom bien definidos. Esta arquitectura sigue el principio de "separación de concerns" y facilita el mantenimiento, testing y escalabilidad.
1.1 Mapa de Módulos
Módulo	Tipo	Responsabilidad
jaraba_core	Core	Lógica de negocio central, servicios compartidos, APIs base
jaraba_tenant	Core	Gestión multi-tenant, integración Group Module, context provider
jaraba_foc	FOC	Dashboard financiero, routing, permisos FOC
jaraba_foc_entities	FOC	Entidades financieras: transaction, allocation, snapshot
jaraba_foc_etl	FOC	ETL: webhooks Stripe, sync ActiveCampaign, Make.com
jaraba_foc_metrics	FOC	Cálculo métricas SaaS: MRR, ARR, Churn, LTV, CAC
jaraba_foc_forecasting	FOC	Proyecciones PHP-ML, escenarios, sensitivity analysis
jaraba_stripe	Payments	Stripe Connect, Destination Charges, Express onboarding
jaraba_diagnostic	Vertical	Diagnóstico Express, Calculadora Madurez, TTV
jaraba_ai	AI	RAG, copilots, grounding, integración Qdrant
jaraba_webhooks	Integration	Sistema de webhooks salientes, eventos, Make.com
jaraba_geo	SEO	Answer Capsules, llms.txt, Schema.org automation
1.2 Diagrama de Dependencias
                     ┌─────────────────────────────────────┐                     │           jaraba_core               │                     │  (Base Services, Configuration)     │                     └───────────────┬─────────────────────┘                                     │           ┌─────────────────────────┼─────────────────────────┐           │                         │                         │           ▼                         ▼                         ▼ ┌─────────────────┐      ┌─────────────────┐      ┌─────────────────┐ │  jaraba_tenant  │      │  jaraba_stripe  │      │   jaraba_ai     │ │ (Multi-Tenant)  │      │ (Payments)      │      │ (RAG/Copilots)  │ └────────┬────────┘      └────────┬────────┘      └────────┬────────┘          │                        │                        │          └────────────────────────┼────────────────────────┘                                   │                     ┌─────────────┴─────────────┐                     │                           │                     ▼                           ▼           ┌─────────────────┐         ┌─────────────────┐           │   jaraba_foc    │         │ jaraba_webhooks │           │ (Financial Ops) │         │ (Events Out)    │           └────────┬────────┘         └─────────────────┘                    │     ┌──────────────┼──────────────┐     │              │              │     ▼              ▼              ▼ ┌────────┐   ┌──────────┐   ┌────────────┐ │entities│   │   etl    │   │ forecasting│ └────────┘   └──────────┘   └────────────┘ 
 
2. Módulo: jaraba_core
El módulo core contiene los servicios base, configuración global, y utilidades compartidas por todos los demás módulos. Es la piedra angular de la plataforma.
2.1 Estructura de Archivos
 jaraba_core/ ├── jaraba_core.info.yml ├── jaraba_core.module ├── jaraba_core.services.yml ├── jaraba_core.permissions.yml ├── jaraba_core.routing.yml ├── config/ │   ├── install/ │   │   └── jaraba_core.settings.yml │   └── schema/ │       └── jaraba_core.schema.yml ├── src/ │   ├── JarabaCoreServiceProvider.php │   ├── Service/ │   │   ├── ConfigurationService.php │   │   ├── TrazabilidadService.php │   │   ├── QrGeneratorService.php │   │   └── VerticalContextService.php │   ├── Controller/ │   │   ├── QrController.php │   │   ├── TrazabilidadController.php │   │   └── ApiBaseController.php │   ├── Form/ │   │   └── SettingsForm.php │   ├── Plugin/ │   │   └── Block/ │   │       └── VerticalSelectorBlock.php │   └── EventSubscriber/ │       └── ConfigEventSubscriber.php └── tests/     └── src/         └── Unit/             └── TrazabilidadServiceTest.php
2.2 Servicios Principales
2.2.1 ConfigurationService
Gestiona la configuración global de la plataforma con soporte multi-tenant:
 <?php namespace Drupal\jaraba_core\Service;  class ConfigurationService {      public function __construct(     private ConfigFactoryInterface $configFactory,     private TenantContextService $tenantContext   ) {}      /**    * Obtiene configuración con cascada: Tenant > Vertical > Platform.    */   public function get(string $key, mixed $default = NULL): mixed {     $tenantConfig = $this->getTenantConfig($key);     if ($tenantConfig !== NULL) return $tenantConfig;          $verticalConfig = $this->getVerticalConfig($key);     if ($verticalConfig !== NULL) return $verticalConfig;          return $this->getPlatformConfig($key) ?? $default;   }      /**    * Obtiene la comisión aplicable al tenant actual.    */   public function getPlatformFee(): float {     $tenant = $this->tenantContext->getCurrentTenant();     return $tenant?->get('platform_fee_percent')->value ?? 5.0;   } }
2.2.2 TrazabilidadService
Genera identificadores únicos para trazabilidad 'Phy-gital':
 <?php namespace Drupal\jaraba_core\Service;  class TrazabilidadService {      private const PREFIX = 'LOTE';   private const YEAR_FORMAT = 'Y';      public function generateLoteId(string $vertical = 'GEN'): string {     $year = date(self::YEAR_FORMAT);     $sequence = $this->getNextSequence($vertical, $year);          return sprintf(       '%s-%s-%s-%04d',       self::PREFIX,       $year,       strtoupper(substr($vertical, 0, 3)),       $sequence     );     // Output: LOTE-2026-AGR-0001   }      public function generateQrUrl(string $loteId): string {     return Url::fromRoute('jaraba_core.trazabilidad',        ['lote_id' => $loteId],       ['absolute' => TRUE]     )->toString();   } }
 
3. Módulo: jaraba_tenant
Gestiona el contexto multi-tenant, integración con Group Module, y proporciona el TenantContextService que es utilizado por todos los demás módulos.
3.1 TenantContextService
Servicio central que determina el tenant actual basándose en múltiples señales:
 <?php namespace Drupal\jaraba_tenant\Service;  class TenantContextService {      public function __construct(     private EntityTypeManagerInterface $entityTypeManager,     private RequestStack $requestStack,     private AccountInterface $currentUser   ) {}      /**    * Determina el tenant actual por prioridad:    * 1. Parámetro de ruta explícito    * 2. Dominio/subdominio    * 3. Group membership del usuario    * 4. Session storage    */   public function getCurrentTenant(): ?TenantInterface {     // 1. Route parameter     $request = $this->requestStack->getCurrentRequest();     if ($tenantId = $request->attributes->get('tenant')) {       return $this->loadTenant($tenantId);     }          // 2. Domain matching     $host = $request->getHost();     if ($tenant = $this->findTenantByDomain($host)) {       return $tenant;     }          // 3. User's primary group     if ($this->currentUser->isAuthenticated()) {       return $this->getUserPrimaryTenant($this->currentUser->id());     }          return NULL;   }      /**    * Inyecta filtro de tenant en queries de entidades.    */   public function applyTenantFilter(QueryInterface $query): void {     $tenant = $this->getCurrentTenant();     if ($tenant) {       $query->condition('tenant_id', $tenant->id());     }   } }
3.2 Query Alter Hook
Intercepta todas las queries para aplicar filtrado automático por tenant:
 <?php // jaraba_tenant.module  use Drupal\Core\Database\Query\AlterableInterface;  /**  * Implements hook_query_TAG_alter() para aislamiento multi-tenant.  */ function jaraba_tenant_query_tenant_aware_alter(AlterableInterface $query) {   $tenantContext = \Drupal::service('jaraba_tenant.context');   $tenant = $tenantContext->getCurrentTenant();      if (!$tenant) {     return;   }      // Aplicar filtro solo si la tabla tiene campo tenant_id   $tables = $query->getTables();   foreach ($tables as $alias => $table) {     if ($tenantContext->isTenantAwareTable($table['table'])) {       $query->condition($alias . '.tenant_id', $tenant->id());     }   } }  /**  * Implements hook_entity_query_alter().  */ function jaraba_tenant_entity_query_alter(QueryInterface $query) {   $entityType = $query->getEntityTypeId();   $tenantAwareTypes = [     'financial_transaction',     'cost_allocation',      'commerce_product',     'commerce_order',     'diagnostic_express_result',     'ai_query_log'   ];      if (in_array($entityType, $tenantAwareTypes)) {     $query->addTag('tenant_aware');   } }
 
4. Módulo: jaraba_stripe
Implementa la integración con Stripe Connect usando el modelo Destination Charges, que simplifica la operativa fiscal y permite split automático de pagos.
4.1 StripeConnectService
 <?php namespace Drupal\jaraba_stripe\Service;  use Stripe\StripeClient;  class StripeConnectService {      private StripeClient $stripe;      public function __construct(     private ConfigurationService $config,     private LoggerInterface $logger   ) {     $this->stripe = new StripeClient($config->get('stripe.secret_key'));   }      /**    * Crea cuenta Express para nuevo tenant.    */   public function createConnectedAccount(     string $email,     string $country = 'ES',     string $businessType = 'individual'   ): Account {     return $this->stripe->accounts->create([       'type' => 'express',       'country' => $country,       'email' => $email,       'business_type' => $businessType,       'capabilities' => [         'card_payments' => ['requested' => true],         'transfers' => ['requested' => true],       ],     ]);   }      /**    * Genera URL de onboarding KYC.    */   public function createAccountLink(     string $accountId,     string $returnUrl,     string $refreshUrl   ): AccountLink {     return $this->stripe->accountLinks->create([       'account' => $accountId,       'refresh_url' => $refreshUrl,       'return_url' => $returnUrl,       'type' => 'account_onboarding',     ]);   }      /**    * Procesa pago con Destination Charges.    * El dinero va directo al tenant, la plataforma cobra application_fee.    */   public function createPaymentIntent(     int $amount,     string $currency,     string $connectedAccountId,     float $platformFeePercent = 5.0,     array $metadata = []   ): PaymentIntent {     $applicationFee = (int) round($amount * ($platformFeePercent / 100));          return $this->stripe->paymentIntents->create([       'amount' => $amount,       'currency' => $currency,       'application_fee_amount' => $applicationFee,       'transfer_data' => [         'destination' => $connectedAccountId,       ],       'metadata' => array_merge($metadata, [         'platform' => 'jaraba_impact',         'fee_percent' => $platformFeePercent,       ]),     ]);   } }
4.2 Webhook Handler
 <?php namespace Drupal\jaraba_stripe\Controller;  class StripeWebhookController extends ControllerBase {      /**    * Endpoint: /stripe/webhook    */   public function handleWebhook(Request $request): Response {     $payload = $request->getContent();     $signature = $request->headers->get('Stripe-Signature');          try {       $event = Webhook::constructEvent(         $payload,         $signature,         $this->config->get('stripe.webhook_secret')       );     } catch (\Exception $e) {       return new Response('Invalid signature', 400);     }          // Dispatch a handlers específicos     match($event->type) {       'payment_intent.succeeded' => $this->handlePaymentSuccess($event),       'payment_intent.payment_failed' => $this->handlePaymentFailed($event),       'account.updated' => $this->handleAccountUpdate($event),       'charge.refunded' => $this->handleRefund($event),       default => $this->logger->info('Unhandled event: @type', ['@type' => $event->type])     };          return new Response('OK', 200);   }      private function handlePaymentSuccess(Event $event): void {     $paymentIntent = $event->data->object;          // Crear financial_transaction     $transaction = $this->entityTypeManager       ->getStorage('financial_transaction')       ->create([         'uuid' => Uuid::uuid4()->toString(),         'amount' => $paymentIntent->amount / 100,         'currency' => strtoupper($paymentIntent->currency),         'transaction_type' => 'income_one_time',         'source_system' => 'stripe_connect',         'external_id' => $paymentIntent->id,         'tenant_id' => $paymentIntent->metadata['tenant_id'] ?? NULL,         'platform_fee' => ($paymentIntent->application_fee_amount ?? 0) / 100,         'processor_fee' => $this->calculateStripeFee($paymentIntent->amount),         'timestamp' => new \DateTime('@' . $paymentIntent->created),         'metadata' => json_encode($paymentIntent->metadata),       ]);          $transaction->save();          // Emitir evento para Make.com y otros sistemas     $this->eventDispatcher->dispatch(       new PaymentReceivedEvent($transaction),       PaymentReceivedEvent::EVENT_NAME     );   } }
 
5. Módulo: jaraba_foc_metrics
Implementa el cálculo de todas las métricas SaaS definidas en el Marco de Métricas 2.0. Los cálculos se ejecutan en batch nocturno y generan snapshots diarios.
5.1 MetricsCalculationService
 <?php namespace Drupal\jaraba_foc_metrics\Service;  class MetricsCalculationService {      /**    * Calcula MRR (Monthly Recurring Revenue).    * MRR = Suma de todos los ingresos recurrentes mensualizados.    */   public function calculateMrr(?int $tenantId = NULL, ?int $verticalId = NULL): float {     $query = $this->database->select('financial_transaction', 'ft')       ->condition('ft.transaction_type', ['income_recurring', 'income_subscription'], 'IN')       ->condition('ft.timestamp', strtotime('-30 days'), '>=');          if ($tenantId) {       $query->condition('ft.tenant_id', $tenantId);     }     if ($verticalId) {       $query->condition('ft.vertical_id', $verticalId);     }          $query->addExpression('SUM(ft.amount)', 'total');     $result = $query->execute()->fetchField();          return (float) ($result ?? 0);   }      /**    * Calcula Revenue Churn Rate.    * Churn = MRR perdido por churned customers / MRR inicio de período.    */   public function calculateRevenueChurn(?int $tenantId = NULL): float {     $startMrr = $this->getMrrAtDate(strtotime('-30 days'), $tenantId);     if ($startMrr == 0) return 0;          $churnedMrr = $this->getChurnedMrr($tenantId);          return round($churnedMrr / $startMrr, 4);   }      /**    * Calcula Net Revenue Retention (NRR).    * NRR = (MRR inicio + Expansión - Contracción - Churn) / MRR inicio.    * Target: > 100% (crecimiento neto de cohorte existente).    */   public function calculateNrr(?int $tenantId = NULL): float {     $startMrr = $this->getMrrAtDate(strtotime('-30 days'), $tenantId);     if ($startMrr == 0) return 1;          $expansion = $this->getExpansionMrr($tenantId);     $contraction = $this->getContractionMrr($tenantId);     $churn = $this->getChurnedMrr($tenantId);          return round(($startMrr + $expansion - $contraction - $churn) / $startMrr, 4);   }      /**    * Calcula LTV (Customer Lifetime Value).    * LTV = (ARPU × Gross Margin) / Revenue Churn Rate.    */   public function calculateLtv(?int $tenantId = NULL): float {     $arpu = $this->calculateArpu($tenantId);     $grossMargin = $this->calculateGrossMargin($tenantId);     $churnRate = $this->calculateRevenueChurn($tenantId);          if ($churnRate == 0) {       return $arpu * $grossMargin * 60; // Cap at 5 years     }          return round(($arpu * $grossMargin) / $churnRate, 2);   }      /**    * Calcula CAC (Customer Acquisition Cost).    * CAC = Total Marketing & Sales Costs / New Customers Acquired.    */   public function calculateCac(string $period = '-30 days'): float {     $marketingCosts = $this->getMarketingCosts($period);     $newCustomers = $this->getNewCustomersCount($period);          if ($newCustomers == 0) return 0;          return round($marketingCosts / $newCustomers, 2);   } }
5.2 Batch Processor
 <?php namespace Drupal\jaraba_foc_metrics\Service;  class MetricsSnapshotService {      /**    * Genera snapshot diario de métricas.    * Se ejecuta via cron a las 02:00 UTC.    */   public function generateDailySnapshot(): void {     $date = new \DateTime('today');          // 1. Snapshot a nivel plataforma     $this->createSnapshot('platform', NULL, $date);          // 2. Snapshot por cada vertical     $verticals = $this->entityTypeManager       ->getStorage('taxonomy_term')       ->loadByProperties(['vid' => 'business_verticals']);          foreach ($verticals as $vertical) {       $this->createSnapshot('vertical', $vertical->id(), $date);     }          // 3. Snapshot por cada tenant activo     $tenants = $this->entityTypeManager       ->getStorage('tenant')       ->loadByProperties(['status' => 'active']);          foreach ($tenants as $tenant) {       $this->createSnapshot('tenant', $tenant->id(), $date);     }          $this->logger->info('Daily metrics snapshot completed: @count records', [       '@count' => count($verticals) + count($tenants) + 1     ]);   }      private function createSnapshot(string $scopeType, ?int $scopeId, \DateTime $date): void {     $snapshot = $this->entityTypeManager       ->getStorage('foc_metric_snapshot')       ->create([         'snapshot_date' => $date->format('Y-m-d'),         'scope_type' => $scopeType,         'scope_id' => $scopeId,         'mrr' => $this->metrics->calculateMrr($scopeId),         'arr' => $this->metrics->calculateMrr($scopeId) * 12,         'revenue_churn_rate' => $this->metrics->calculateRevenueChurn($scopeId),         'nrr' => $this->metrics->calculateNrr($scopeId),         'grr' => $this->metrics->calculateGrr($scopeId),         'cac' => $scopeType === 'platform' ? $this->metrics->calculateCac() : NULL,         'ltv' => $this->metrics->calculateLtv($scopeId),         'gross_margin' => $this->metrics->calculateGrossMargin($scopeId),         'active_users' => $this->metrics->getActiveUsersCount($scopeId),         'gmv' => $this->metrics->calculateGmv($scopeId),       ]);          $snapshot->save();   } }
 
6. Módulo: jaraba_diagnostic
Implementa el sistema de diagnósticos de valor rápido (TTV < 60s) para los verticales de Empleabilidad y Emprendimiento.
6.1 DiagnosticEngineService
 <?php namespace Drupal\jaraba_diagnostic\Service;  class DiagnosticEngineService {      private const SCORE_WEIGHTS = [     'linkedin' => ['none' => 0, 'basic' => 2, 'active' => 4],     'cv' => ['none' => 0, 'outdated' => 1, 'recent' => 3],     'search' => ['passive' => 0, 'occasional' => 1, 'active' => 3],   ];      private const PROFILE_THRESHOLDS = [     'invisible' => [0, 2],     'desconectado' => [3, 4],     'construccion' => [5, 6],     'competitivo' => [7, 8],     'magnetico' => [9, 10],   ];      /**    * Calcula resultado del diagnóstico express.    */   public function calculate(array $answers): DiagnosticResult {     $score = $this->calculateScore($answers);     $profile = $this->determineProfile($score);     $gap = $this->identifyPrimaryGap($answers);     $action = $this->recommendAction($profile, $gap);          return new DiagnosticResult(       score: $score,       profile: $profile,       primaryGap: $gap,       recommendedAction: $action,       answers: $answers     );   }      private function calculateScore(array $answers): int {     $total = 0;     foreach ($answers as $question => $answer) {       $total += self::SCORE_WEIGHTS[$question][$answer] ?? 0;     }     return min(10, $total);   }      private function identifyPrimaryGap(array $answers): string {     $gaps = [];          if ($answers['linkedin'] === 'none') {       $gaps['linkedin'] = 4;     } elseif ($answers['linkedin'] === 'basic') {       $gaps['linkedin'] = 2;     }          if ($answers['cv'] === 'none' || $answers['cv'] === 'outdated') {       $gaps['cv'] = 3;     }          if ($answers['search'] === 'passive') {       $gaps['search_strategy'] = 3;     }          arsort($gaps);     return array_key_first($gaps) ?? 'linkedin';   }      private function recommendAction(string $profile, string $gap): string {     return match($gap) {       'linkedin' => 'Crea tu perfil de LinkedIn en 15 minutos con nuestra guía paso a paso',       'cv' => 'Actualiza tu CV con nuestra plantilla ATS-friendly en 20 minutos',       'search_strategy' => 'Activa tu estrategia de búsqueda con 3 acciones diarias',       default => 'Completa tu perfil digital con el módulo básico'     };   } }
6.2 Integración ECA
Configuración YAML del flujo ECA post-diagnóstico:
 # config/install/eca.model.diagnostic_express_flow.yml id: diagnostic_express_flow label: 'Flujo Post-Diagnóstico Express' status: true events:   - plugin: 'entity_insert:diagnostic_express_result'     configuration:       entity_type_id: diagnostic_express_result  conditions:   - plugin: 'entity_field_value'     configuration:       field_name: user_id       operator: 'is not empty'      actions:   # 1. Asignar rol según score   - plugin: 'eca_user_assign_role'     configuration:       role_id:          switch:           - condition: '[entity:score_total] <= 4'             value: 'empleabilidad_urgente'           - condition: '[entity:score_total] <= 6'               value: 'empleabilidad_desarrollo'           - default:             value: 'empleabilidad_optimizacion'        # 2. Webhook a ActiveCampaign   - plugin: 'eca_webhook'     configuration:       url: 'https://jaraba.api-us1.com/api/3/contacts'       method: POST       body: |         {           "contact": {             "email": "[user:mail]",             "tags": ["diagnostico_express", "gap_[entity:primary_gap]"],             "fieldValues": [               {"field": "score_diagnostico", "value": "[entity:score_total]"},               {"field": "perfil_digital", "value": "[entity:profile_type]"}             ]           }         }            # 3. Asignar créditos de impacto   - plugin: 'eca_update_entity'     configuration:       entity_type: user_profile_extended       entity_id: '[user:uid]'       fields:         impact_credits: '[user:user_profile_extended:impact_credits] + 50'
 
7. Módulo: jaraba_webhooks
Sistema de eventos salientes que permite integración con Make.com, Zapier, y sistemas externos mediante webhooks configurables por tenant.
7.1 Eventos Disponibles
Evento	Trigger	Payload
product.created	Nuevo producto	Product entity JSON + tenant_id + vertical_id
product.updated	Producto editado	Product entity JSON + changed_fields
order.completed	Pedido pagado	Order + items + customer + payment info
order.cancelled	Pedido cancelado	Order + cancellation_reason
cart.abandoned	Carrito 2h sin completar	Cart + items + user (si logueado)
user.registered	Nuevo usuario	User entity + tenant_id + source
diagnostic.completed	Diagnóstico completado	Score + profile + gap + user (si registrado)
tenant.onboarded	Tenant completa KYC	Tenant entity + stripe_account status
alert.triggered	Alerta FOC activada	Alert type + severity + affected entities
7.2 WebhookDispatcherService
 <?php namespace Drupal\jaraba_webhooks\Service;  class WebhookDispatcherService {      public function dispatch(string $eventName, array $payload): void {     // Obtener endpoints registrados para este evento     $endpoints = $this->getEndpointsForEvent($eventName);          foreach ($endpoints as $endpoint) {       // Verificar que el endpoint pertenece al tenant del payload       if (!$this->canDispatchToEndpoint($endpoint, $payload)) {         continue;       }              // Preparar payload con firma HMAC       $signedPayload = $this->signPayload($payload, $endpoint->getSecret());              // Encolar para envío asíncrono       $this->queue->createItem([         'endpoint_url' => $endpoint->getUrl(),         'payload' => $signedPayload,         'headers' => [           'Content-Type' => 'application/json',           'X-Jaraba-Event' => $eventName,           'X-Jaraba-Signature' => $signedPayload['signature'],           'X-Jaraba-Timestamp' => time(),         ],         'retries' => 0,         'max_retries' => 3,       ]);     }   }      private function signPayload(array $payload, string $secret): array {     $timestamp = time();     $body = json_encode($payload);     $signature = hash_hmac('sha256', $timestamp . '.' . $body, $secret);          return [       'data' => $payload,       'signature' => $signature,       'timestamp' => $timestamp,     ];   } }
 
8. Registro de Servicios
Archivo jaraba_core.services.yml consolidado:
 # jaraba_core/jaraba_core.services.yml services:   # === CORE SERVICES ===   jaraba_core.configuration:     class: Drupal\jaraba_core\Service\ConfigurationService     arguments: ['@config.factory', '@jaraba_tenant.context']        jaraba_core.trazabilidad:     class: Drupal\jaraba_core\Service\TrazabilidadService     arguments: ['@database', '@jaraba_tenant.context']        jaraba_core.qr_generator:     class: Drupal\jaraba_core\Service\QrGeneratorService     arguments: ['@jaraba_core.trazabilidad', '@file_system']    # === TENANT SERVICES ===   jaraba_tenant.context:     class: Drupal\jaraba_tenant\Service\TenantContextService     arguments: ['@entity_type.manager', '@request_stack', '@current_user']        # === STRIPE SERVICES ===   jaraba_stripe.connect:     class: Drupal\jaraba_stripe\Service\StripeConnectService     arguments: ['@jaraba_core.configuration', '@logger.channel.jaraba_stripe']        # === FOC SERVICES ===   jaraba_foc.metrics:     class: Drupal\jaraba_foc_metrics\Service\MetricsCalculationService     arguments: ['@database', '@entity_type.manager', '@jaraba_tenant.context']        jaraba_foc.snapshot:     class: Drupal\jaraba_foc_metrics\Service\MetricsSnapshotService     arguments: ['@entity_type.manager', '@jaraba_foc.metrics', '@logger.channel.jaraba_foc']        jaraba_foc.forecasting:     class: Drupal\jaraba_foc_forecasting\Service\ForecastingService     arguments: ['@database', '@jaraba_foc.metrics']        # === DIAGNOSTIC SERVICES ===   jaraba_diagnostic.engine:     class: Drupal\jaraba_diagnostic\Service\DiagnosticEngineService     arguments: ['@jaraba_core.configuration']        # === WEBHOOK SERVICES ===   jaraba_webhooks.dispatcher:     class: Drupal\jaraba_webhooks\Service\WebhookDispatcherService     arguments: ['@entity_type.manager', '@queue.jaraba_webhooks', '@logger.channel.jaraba_webhooks']        # === AI SERVICES ===   jaraba_ai.rag:     class: Drupal\jaraba_ai\Service\RagService     arguments: ['@jaraba_tenant.context', '@http_client', '@jaraba_core.configuration']        jaraba_ai.grounding:     class: Drupal\jaraba_ai\Service\GroundingValidatorService     arguments: ['@http_client']
 
9. Roadmap de Implementación
Sprint	Módulos	Entregables	Dependencias
1-2	jaraba_core, jaraba_tenant	Servicios base, TenantContext, configuración multi-nivel	Drupal 11, Group Module
3-4	jaraba_stripe	Stripe Connect, Destination Charges, webhooks entrada	Cuenta Stripe Connect
5-6	jaraba_foc_entities, jaraba_foc_etl	Entidades financieras, ETL Stripe/AC, importadores	jaraba_stripe
7-8	jaraba_foc_metrics, jaraba_foc	Calculadores métricas, snapshots, dashboard FOC	jaraba_foc_entities
9-10	jaraba_diagnostic, jaraba_webhooks	Diagnóstico Express, Calculadora Madurez, eventos salientes	jaraba_core
11-12	jaraba_ai, jaraba_geo	RAG Qdrant, copilots, Answer Capsules, llms.txt	Qdrant Cloud

FIN DEL DOCUMENTO
Especificación de Módulos Personalizados v1.0 | Jaraba Impact Platform | Enero 2026
