APLICACI√ìN M√ìVIL
Apps Nativas iOS/Android para Clientes y Comerciantes
Vertical ComercioConecta
JARABA IMPACT PLATFORM
Documento T√©cnico de Implementaci√≥n

Campo	Valor
Versi√≥n:	1.0
Fecha:	Enero 2026
Estado:	Especificaci√≥n T√©cnica
C√≥digo:	77_ComercioConecta_Mobile_App
Dependencias:	74_Merchant_Portal, 75_Customer_Portal, 76_Notifications
Tecnolog√≠a:	React Native + Expo
‚ÄÉ
1. Resumen Ejecutivo
Este documento especifica las Aplicaciones M√≥viles Nativas para ComercioConecta. Se desarrollar√°n dos apps separadas: ComercioConecta para clientes (compras, seguimiento, fidelizaci√≥n) y ComercioConecta Business para comerciantes (gesti√≥n de pedidos, inventario, notificaciones).
1.1 Objetivos de las Apps
‚Ä¢ Proporcionar experiencia de compra m√≥vil optimizada
‚Ä¢ Habilitar gesti√≥n de comercio sobre la marcha
‚Ä¢ Push notifications en tiempo real
‚Ä¢ Funcionalidades offline para operaciones cr√≠ticas
‚Ä¢ Integraci√≥n con c√°mara para esc√°ner de productos y QR
‚Ä¢ Biometr√≠a para login seguro
1.2 Aplicaciones a Desarrollar
App	Audiencia	Stores	Prioridad
ComercioConecta	Clientes finales	App Store, Google Play	Alta
ComercioConecta Business	Comerciantes y staff	App Store, Google Play	Alta
1.3 Stack Tecnol√≥gico
Componente	Tecnolog√≠a	Justificaci√≥n
Framework	React Native 0.73+	Cross-platform, ecosystem React
Tooling	Expo SDK 50+	Build simplificado, OTA updates
Navigation	Expo Router	File-based routing, deep links
State	Zustand + React Query	Simple, performante, cache
UI	Tamagui / NativeWind	Design system, performance
Forms	React Hook Form + Zod	Validaci√≥n, performance
Storage	MMKV + SQLite	Fast KV + structured data
Push	Expo Notifications + FCM	Cross-platform push
Camera	Expo Camera + Vision	Barcode/QR scanning
Maps	React Native Maps	Ubicaci√≥n tiendas, tracking
‚ÄÉ
2. App del Cliente: ComercioConecta
2.1 Funcionalidades Principales
M√≥dulo	Funcionalidades	Prioridad
Explorar	Home, categor√≠as, b√∫squeda, filtros, comercios cercanos	Cr√≠tica
Producto	Detalle, variantes, galer√≠a, rese√±as, a√±adir carrito	Cr√≠tica
Carrito	Items, cantidades, cupones, checkout	Cr√≠tica
Checkout	Direcciones, env√≠o/C&C, pago (Apple/Google Pay)	Cr√≠tica
Pedidos	Historial, detalle, tracking, devoluciones	Alta
Cuenta	Perfil, direcciones, favoritos, puntos, configuraci√≥n	Alta
Fidelizaci√≥n	Puntos, nivel, canjear, historial	Alta
Notificaciones	Centro de notificaciones, preferencias	Alta
Esc√°ner	Buscar producto por c√≥digo de barras	Media
Click & Collect	QR de recogida, mapa de tiendas	Alta
2.2 Arquitectura de Navegaci√≥n
app/ ‚îú‚îÄ‚îÄ (tabs)/                      # Tab Navigator principal ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx                # Home / Explorar ‚îÇ   ‚îú‚îÄ‚îÄ search.tsx               # B√∫squeda ‚îÇ   ‚îú‚îÄ‚îÄ cart.tsx                 # Carrito ‚îÇ   ‚îú‚îÄ‚îÄ orders.tsx               # Mis Pedidos ‚îÇ   ‚îî‚îÄ‚îÄ account.tsx              # Mi Cuenta ‚îÇ ‚îú‚îÄ‚îÄ (auth)/                      # Auth Stack ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx ‚îÇ   ‚îú‚îÄ‚îÄ register.tsx ‚îÇ   ‚îú‚îÄ‚îÄ forgot-password.tsx ‚îÇ   ‚îî‚îÄ‚îÄ verify-email.tsx ‚îÇ ‚îú‚îÄ‚îÄ product/ ‚îÇ   ‚îî‚îÄ‚îÄ [id].tsx                 # Detalle de producto ‚îÇ ‚îú‚îÄ‚îÄ merchant/ ‚îÇ   ‚îî‚îÄ‚îÄ [id].tsx                 # Perfil de comercio ‚îÇ ‚îú‚îÄ‚îÄ category/ ‚îÇ   ‚îî‚îÄ‚îÄ [slug].tsx               # Listado por categor√≠a ‚îÇ ‚îú‚îÄ‚îÄ checkout/ ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx                # Resumen ‚îÇ   ‚îú‚îÄ‚îÄ address.tsx              # Seleccionar direcci√≥n ‚îÇ   ‚îú‚îÄ‚îÄ shipping.tsx             # M√©todo de env√≠o ‚îÇ   ‚îú‚îÄ‚îÄ payment.tsx              # Pago ‚îÇ   ‚îî‚îÄ‚îÄ confirm.tsx              # Confirmaci√≥n ‚îÇ ‚îú‚îÄ‚îÄ order/ ‚îÇ   ‚îú‚îÄ‚îÄ [id].tsx                 # Detalle de pedido ‚îÇ   ‚îú‚îÄ‚îÄ [id]/tracking.tsx        # Tracking ‚îÇ   ‚îî‚îÄ‚îÄ [id]/return.tsx          # Devoluci√≥n ‚îÇ ‚îú‚îÄ‚îÄ account/ ‚îÇ   ‚îú‚îÄ‚îÄ profile.tsx              # Editar perfil ‚îÇ   ‚îú‚îÄ‚îÄ addresses.tsx            # Direcciones ‚îÇ   ‚îú‚îÄ‚îÄ wishlist.tsx             # Favoritos ‚îÇ   ‚îú‚îÄ‚îÄ loyalty.tsx              # Puntos ‚îÇ   ‚îú‚îÄ‚îÄ reviews.tsx              # Mis rese√±as ‚îÇ   ‚îî‚îÄ‚îÄ settings.tsx             # Configuraci√≥n ‚îÇ ‚îú‚îÄ‚îÄ scanner.tsx                  # Esc√°ner de barras ‚îú‚îÄ‚îÄ notifications.tsx            # Centro de notificaciones ‚îî‚îÄ‚îÄ _layout.tsx                  # Root layout
‚ÄÉ
2.3 Pantalla Home
// app/(tabs)/index.tsx - Home Screen import { ScrollView, RefreshControl } from 'react-native'; import { useQuery } from '@tanstack/react-query';  export default function HomeScreen() {   const { data: home, refetch, isRefetching } = useQuery({     queryKey: ['home'],     queryFn: () => api.getHomeFeed(),   });    return (     <ScrollView       refreshControl={         <RefreshControl refreshing={isRefetching} onRefresh={refetch} />       }     >       {/* Header con ubicaci√≥n */}       <LocationHeader />              {/* Barra de b√∫squeda */}       <SearchBar onPress={() => router.push('/search')} />              {/* Banner promocional */}       <PromoBanner banners={home?.banners} />              {/* Categor√≠as principales */}       <CategoryGrid categories={home?.categories} />              {/* Flash Offers activas */}       {home?.flashOffers?.length > 0 && (         <Section title="‚ö° Ofertas Flash">           <FlashOfferCarousel offers={home.flashOffers} />         </Section>       )}              {/* Comercios cerca de ti */}       <Section title="üìç Cerca de ti" onSeeAll={() => router.push('/nearby')}>         <MerchantCarousel merchants={home?.nearbyMerchants} />       </Section>              {/* Productos recomendados */}       <Section title="Para ti" onSeeAll={() => router.push('/recommended')}>         <ProductGrid products={home?.recommended} columns={2} />       </Section>              {/* Productos vistos recientemente */}       {home?.recentlyViewed?.length > 0 && (         <Section title="Vistos recientemente">           <ProductCarousel products={home.recentlyViewed} />         </Section>       )}     </ScrollView>   ); }
2.4 Pantalla de Producto
// app/product/[id].tsx - Product Detail export default function ProductScreen() {   const { id } = useLocalSearchParams();   const { data: product } = useQuery({     queryKey: ['product', id],     queryFn: () => api.getProduct(id),   });      const [selectedVariation, setSelectedVariation] = useState(null);   const addToCart = useAddToCart();   const toggleWishlist = useToggleWishlist();    return (     <View style={styles.container}>       <ScrollView>         {/* Galer√≠a de im√°genes con zoom */}         <ImageGallery           images={product?.images}           onShare={() => shareProduct(product)}         />                  {/* Info del comercio */}         <MerchantBadge           merchant={product?.merchant}           onPress={() => router.push(`/merchant/${product.merchant.id}`)}         />                  {/* T√≠tulo y precio */}         <View style={styles.header}>           <Text style={styles.title}>{product?.title}</Text>           <PriceDisplay             price={selectedVariation?.price || product?.price}             salePrice={selectedVariation?.salePrice || product?.salePrice}           />         </View>                  {/* Rating */}         <RatingBadge           rating={product?.rating}           count={product?.reviewCount}           onPress={() => scrollToReviews()}         />                  {/* Selector de variantes */}         {product?.hasVariations && (           <VariantSelector             attributes={product.attributes}             variations={product.variations}             selected={selectedVariation}             onSelect={setSelectedVariation}           />         )}                  {/* Disponibilidad */}         <StockIndicator           inStock={selectedVariation?.inStock ?? product?.inStock}           quantity={selectedVariation?.stockQuantity}         />                  {/* Env√≠o */}         <ShippingInfo product={product} />                  {/* Descripci√≥n */}         <ExpandableText           title="Descripci√≥n"           text={product?.description}           initialLines={3}         />                  {/* Rese√±as */}         <ReviewsSection           productId={id}           rating={product?.rating}           reviewCount={product?.reviewCount}         />                  {/* Productos relacionados */}         <Section title="Tambi√©n te puede gustar">           <ProductCarousel products={product?.related} />         </Section>       </ScrollView>              {/* Bottom bar fijo */}       <View style={styles.bottomBar}>         <IconButton           icon={product?.isInWishlist ? 'heart-filled' : 'heart'}           onPress={() => toggleWishlist(id)}         />         <Button           title="A√±adir al carrito"           onPress={() => addToCart(id, selectedVariation?.id, 1)}           disabled={!product?.inStock}           style={styles.addButton}         />       </View>     </View>   ); }
‚ÄÉ
2.5 Flujo de Checkout
// Checkout Flow - 4 pasos  // PASO 1: Direcci√≥n (checkout/address.tsx) - Seleccionar direcci√≥n guardada - O a√±adir nueva direcci√≥n - Validaci√≥n con Google Places - Guardar para futuras compras  // PASO 2: M√©todo de env√≠o (checkout/shipping.tsx) - Opciones seg√∫n direcci√≥n:   ‚Ä¢ Env√≠o est√°ndar (2-5 d√≠as)   ‚Ä¢ Env√≠o express (24-48h)   ‚Ä¢ Click & Collect (seleccionar tienda)   ‚Ä¢ Entrega local mismo d√≠a (si disponible) - Mostrar precio y tiempo estimado - Seleccionar slot horario si aplica  // PASO 3: Pago (checkout/payment.tsx) - Apple Pay / Google Pay (recomendado) - Tarjeta guardada - Nueva tarjeta (Stripe Elements) - Bizum (redirect) - PayPal (redirect) - Pago en tienda (solo C&C) - Aplicar cup√≥n - Usar puntos de fidelidad  // PASO 4: Confirmaci√≥n (checkout/confirm.tsx) - Resumen completo - T√©rminos y condiciones - Bot√≥n de confirmar pedido - Loading state durante procesamiento - Manejo de errores (stock, pago)  // Post-checkout: - Pantalla de √©xito con confetti üéâ - N√∫mero de pedido - Bot√≥n ver pedido - Opci√≥n de compartir
2.6 Checkout con Apple/Google Pay
// hooks/useNativePay.ts import { ApplePay, GooglePay } from '@stripe/stripe-react-native';  export function useNativePay() {   const { isApplePaySupported } = useApplePay();   const { isGooglePaySupported } = useGooglePay();      const payWithApplePay = async (order: OrderSummary) => {     const { error, paymentMethod } = await presentApplePay({       cartItems: order.items.map(item => ({         label: item.title,         amount: item.total.toString(),         paymentType: 'Final',       })),       country: 'ES',       currency: 'EUR',       shippingMethods: order.shippingOptions.map(opt => ({         identifier: opt.id,         label: opt.name,         amount: opt.price.toString(),         detail: opt.deliveryEstimate,       })),       requiredShippingAddressFields: [         'name', 'postalAddress', 'phoneNumber', 'emailAddress'       ],       requiredBillingContactFields: ['name', 'postalAddress'],     });          if (error) {       throw new Error(error.message);     }          // Confirmar con backend     return await api.confirmPayment({       paymentMethodId: paymentMethod.id,       orderId: order.id,     });   };      const payWithGooglePay = async (order: OrderSummary) => {     const { error, paymentMethod } = await presentGooglePay({       testEnv: __DEV__,       merchantName: 'ComercioConecta',       countryCode: 'ES',       currencyCode: 'EUR',       amount: order.total,       allowCreditCards: true,     });          if (error) throw new Error(error.message);          return await api.confirmPayment({       paymentMethodId: paymentMethod.id,       orderId: order.id,     });   };      return {     isApplePaySupported,     isGooglePaySupported,     payWithApplePay,     payWithGooglePay,   }; }
‚ÄÉ
2.7 Tracking de Pedido
// app/order/[id]/tracking.tsx export default function OrderTrackingScreen() {   const { id } = useLocalSearchParams();   const { data: tracking, refetch } = useQuery({     queryKey: ['order-tracking', id],     queryFn: () => api.getOrderTracking(id),     refetchInterval: 30000, // Refetch cada 30s   });    return (     <View style={styles.container}>       {/* Mapa con ubicaci√≥n del paquete */}       {tracking?.currentLocation && (         <MapView           style={styles.map}           initialRegion={{             ...tracking.currentLocation,             latitudeDelta: 0.05,             longitudeDelta: 0.05,           }}         >           {/* Marcador del paquete */}           <Marker coordinate={tracking.currentLocation}>             <TruckIcon size={32} />           </Marker>                      {/* Marcador del destino */}           <Marker coordinate={tracking.destination}>             <HomeIcon size={32} />           </Marker>                      {/* Ruta */}           {tracking.route && (             <Polyline coordinates={tracking.route} strokeWidth={3} />           )}         </MapView>       )}              {/* Timeline de estados */}       <View style={styles.timeline}>         {tracking?.events.map((event, index) => (           <TimelineItem             key={event.id}             title={event.title}             description={event.description}             timestamp={event.timestamp}             isCompleted={event.isCompleted}             isCurrent={index === tracking.currentStep}             isLast={index === tracking.events.length - 1}           />         ))}       </View>              {/* Info del carrier */}       <Card style={styles.carrierCard}>         <Image source={{ uri: tracking?.carrier.logo }} style={styles.carrierLogo} />         <View>           <Text style={styles.carrierName}>{tracking?.carrier.name}</Text>           <Text style={styles.trackingNumber}>             N¬∫ seguimiento: {tracking?.trackingNumber}           </Text>         </View>         <Button           title="Ver en web"           onPress={() => Linking.openURL(tracking.trackingUrl)}           variant="outline"         />       </Card>              {/* ETA */}       {tracking?.eta && (         <Card style={styles.etaCard}>           <ClockIcon />           <Text>Entrega estimada: {formatDate(tracking.eta)}</Text>         </Card>       )}     </View>   ); }
‚ÄÉ
2.8 Click & Collect - QR de Recogida
// app/order/[id]/pickup.tsx import QRCode from 'react-native-qrcode-svg'; import * as Brightness from 'expo-brightness';  export default function PickupScreen() {   const { id } = useLocalSearchParams();   const { data: order } = useQuery({     queryKey: ['order', id],     queryFn: () => api.getOrder(id),   });      // Aumentar brillo al mostrar QR   useEffect(() => {     let originalBrightness;          (async () => {       originalBrightness = await Brightness.getBrightnessAsync();       await Brightness.setBrightnessAsync(1); // M√°ximo brillo     })();          return () => {       if (originalBrightness !== undefined) {         Brightness.setBrightnessAsync(originalBrightness);       }     };   }, []);    return (     <ScrollView style={styles.container}>       {/* C√≥digo de recogida */}       <Card style={styles.codeCard}>         <Text style={styles.codeLabel}>C√≥digo de recogida</Text>         <Text style={styles.codeValue}>{order?.pickupCode}</Text>                  {/* QR Code grande */}         <View style={styles.qrContainer}>           <QRCode             value={order?.pickupQrData}             size={200}             backgroundColor="white"             color="black"           />         </View>                  <Text style={styles.hint}>           Muestra este c√≥digo al personal de la tienda         </Text>       </Card>              {/* Info de la tienda */}       <Card style={styles.storeCard}>         <Text style={styles.sectionTitle}>üìç Recoger en</Text>         <Text style={styles.storeName}>{order?.pickupStore.name}</Text>         <Text style={styles.storeAddress}>{order?.pickupStore.address}</Text>         <Text style={styles.storeHours}>           Horario: {order?.pickupStore.hours}         </Text>                  <View style={styles.storeActions}>           <Button             title="C√≥mo llegar"             icon={<MapIcon />}             onPress={() => openMaps(order.pickupStore)}             variant="outline"           />           <Button             title="Llamar"             icon={<PhoneIcon />}             onPress={() => Linking.openURL(`tel:${order.pickupStore.phone}`)}             variant="outline"           />         </View>       </Card>              {/* Fecha l√≠mite */}       <Card style={[styles.deadlineCard, isExpiringSoon && styles.urgent]}>         <ClockIcon color={isExpiringSoon ? 'orange' : 'gray'} />         <View>           <Text>Recoger antes del</Text>           <Text style={styles.deadline}>             {formatDate(order?.pickupExpiresAt, 'PPPp')}           </Text>         </View>       </Card>              {/* Productos */}       <Card style={styles.itemsCard}>         <Text style={styles.sectionTitle}>Productos a recoger</Text>         {order?.items.map(item => (           <OrderItemRow key={item.id} item={item} compact />         ))}       </Card>     </ScrollView>   ); }
‚ÄÉ
3. App del Comerciante: ComercioConecta Business
3.1 Funcionalidades Principales
M√≥dulo	Funcionalidades	Prioridad
Dashboard	KPIs del d√≠a, alertas, pedidos pendientes	Cr√≠tica
Pedidos	Lista, detalle, procesar, C&C, batch actions	Cr√≠tica
Click & Collect	Esc√°ner QR, confirmar recogida	Cr√≠tica
Inventario	Stock, alertas, ajuste r√°pido con esc√°ner	Alta
Cat√°logo	Ver productos, edici√≥n r√°pida de precio/stock	Alta
Notificaciones	Centro de alertas, configuraci√≥n	Alta
Rese√±as	Ver y responder rese√±as	Media
Analytics	M√©tricas b√°sicas, gr√°ficos	Media
Esc√°ner	C√≥digo de barras, QR de recogida	Cr√≠tica
Configuraci√≥n	Perfil, tienda, usuarios	Media
3.2 Arquitectura de Navegaci√≥n
app/ ‚îú‚îÄ‚îÄ (tabs)/                      # Tab Navigator principal ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx                # Dashboard ‚îÇ   ‚îú‚îÄ‚îÄ orders.tsx               # Pedidos ‚îÇ   ‚îú‚îÄ‚îÄ scanner.tsx              # Esc√°ner central ‚îÇ   ‚îú‚îÄ‚îÄ inventory.tsx            # Inventario ‚îÇ   ‚îî‚îÄ‚îÄ more.tsx                 # M√°s opciones ‚îÇ ‚îú‚îÄ‚îÄ (auth)/                      # Auth Stack ‚îÇ   ‚îú‚îÄ‚îÄ login.tsx ‚îÇ   ‚îî‚îÄ‚îÄ forgot-password.tsx ‚îÇ ‚îú‚îÄ‚îÄ order/ ‚îÇ   ‚îú‚îÄ‚îÄ [id].tsx                 # Detalle de pedido ‚îÇ   ‚îî‚îÄ‚îÄ [id]/process.tsx         # Procesar pedido ‚îÇ ‚îú‚îÄ‚îÄ pickup/ ‚îÇ   ‚îú‚îÄ‚îÄ scan.tsx                 # Esc√°ner C&C ‚îÇ   ‚îî‚îÄ‚îÄ confirm/[code].tsx       # Confirmar recogida ‚îÇ ‚îú‚îÄ‚îÄ product/ ‚îÇ   ‚îú‚îÄ‚îÄ [id].tsx                 # Ver/editar producto ‚îÇ   ‚îî‚îÄ‚îÄ [id]/stock.tsx           # Ajustar stock ‚îÇ ‚îú‚îÄ‚îÄ reviews/ ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx                # Lista de rese√±as ‚îÇ   ‚îî‚îÄ‚îÄ [id].tsx                 # Detalle y responder ‚îÇ ‚îú‚îÄ‚îÄ analytics.tsx                # Analytics ‚îú‚îÄ‚îÄ notifications.tsx            # Centro de notificaciones ‚îú‚îÄ‚îÄ settings/ ‚îÇ   ‚îú‚îÄ‚îÄ index.tsx                # Configuraci√≥n ‚îÇ   ‚îú‚îÄ‚îÄ profile.tsx              # Perfil ‚îÇ   ‚îú‚îÄ‚îÄ store.tsx                # Datos de tienda ‚îÇ   ‚îî‚îÄ‚îÄ team.tsx                 # Equipo ‚îÇ ‚îî‚îÄ‚îÄ _layout.tsx                  # Root layout
‚ÄÉ
3.3 Dashboard del Comerciante
// app/(tabs)/index.tsx - Merchant Dashboard export default function DashboardScreen() {   const { data: dashboard, refetch } = useQuery({     queryKey: ['merchant-dashboard'],     queryFn: () => api.getMerchantDashboard(),     refetchInterval: 60000, // Cada minuto   });    return (     <ScrollView       refreshControl={         <RefreshControl refreshing={isRefetching} onRefresh={refetch} />       }     >       {/* Alertas cr√≠ticas (siempre arriba) */}       {dashboard?.criticalAlerts?.length > 0 && (         <AlertBanner alerts={dashboard.criticalAlerts} />       )}              {/* KPIs del d√≠a */}       <View style={styles.kpiGrid}>         <KPICard           title="Ventas hoy"           value={formatCurrency(dashboard?.salesToday)}           trend={dashboard?.salesTrend}           icon={<EuroIcon />}         />         <KPICard           title="Pedidos"           value={dashboard?.ordersToday}           badge={dashboard?.pendingOrders > 0 ? dashboard.pendingOrders : null}           icon={<ShoppingBagIcon />}           onPress={() => router.push('/orders?status=pending')}         />         <KPICard           title="C&C pendientes"           value={dashboard?.pendingPickups}           urgent={dashboard?.expiringPickups > 0}           icon={<StoreIcon />}           onPress={() => router.push('/orders?fulfillment=click_collect')}         />         <KPICard           title="Stock bajo"           value={dashboard?.lowStockCount}           icon={<AlertIcon />}           onPress={() => router.push('/inventory?filter=low_stock')}         />       </View>              {/* Pedidos pendientes */}       <Section         title="Pedidos pendientes"         badge={dashboard?.pendingOrders}         onSeeAll={() => router.push('/orders?status=pending')}       >         {dashboard?.recentOrders.slice(0, 5).map(order => (           <OrderCard             key={order.id}             order={order}             compact             onPress={() => router.push(`/order/${order.id}`)}           />         ))}       </Section>              {/* Acciones r√°pidas */}       <View style={styles.quickActions}>         <QuickAction           icon={<ScanIcon />}           label="Esc√°ner C&C"           onPress={() => router.push('/pickup/scan')}         />         <QuickAction           icon={<BoxIcon />}           label="Ajustar stock"           onPress={() => router.push('/inventory/adjust')}         />         <QuickAction           icon={<PrinterIcon />}           label="Imprimir etiquetas"           onPress={() => router.push('/orders/print-labels')}         />       </View>              {/* Actividad reciente */}       <Section title="Actividad reciente">         <ActivityFeed activities={dashboard?.recentActivity} />       </Section>     </ScrollView>   ); }
‚ÄÉ
3.4 Gesti√≥n de Pedidos
// app/(tabs)/orders.tsx - Order List export default function OrdersScreen() {   const [filter, setFilter] = useState('all');   const { data, fetchNextPage, hasNextPage } = useInfiniteQuery({     queryKey: ['orders', filter],     queryFn: ({ pageParam = 1 }) => api.getOrders({ page: pageParam, filter }),     getNextPageParam: (lastPage) => lastPage.nextPage,   });    return (     <View style={styles.container}>       {/* Filtros por estado */}       <ScrollView horizontal style={styles.filters}>         <FilterChip           label="Todos"           active={filter === 'all'}           onPress={() => setFilter('all')}         />         <FilterChip           label="Pendientes"           badge={counts?.pending}           active={filter === 'pending'}           onPress={() => setFilter('pending')}         />         <FilterChip           label="En preparaci√≥n"           badge={counts?.processing}           active={filter === 'processing'}           onPress={() => setFilter('processing')}         />         <FilterChip           label="Listos C&C"           badge={counts?.ready_pickup}           active={filter === 'ready_pickup'}           onPress={() => setFilter('ready_pickup')}         />         <FilterChip           label="Enviados"           active={filter === 'shipped'}           onPress={() => setFilter('shipped')}         />       </ScrollView>              {/* Lista de pedidos */}       <FlashList         data={orders}         renderItem={({ item }) => (           <OrderCard             order={item}             onPress={() => router.push(`/order/${item.id}`)}             onQuickAction={(action) => handleQuickAction(item.id, action)}           />         )}         estimatedItemSize={120}         onEndReached={() => hasNextPage && fetchNextPage()}         ListEmptyComponent={<EmptyState message="No hay pedidos" />}       />              {/* FAB para acciones batch */}       {selectedOrders.length > 0 && (         <BatchActionFAB           count={selectedOrders.length}           actions={[             { label: 'Procesar', icon: 'check', onPress: batchProcess },             { label: 'Imprimir', icon: 'printer', onPress: batchPrint },           ]}         />       )}     </View>   ); }
3.5 Detalle y Procesamiento de Pedido
// app/order/[id].tsx - Order Detail export default function OrderDetailScreen() {   const { id } = useLocalSearchParams();   const { data: order } = useQuery({     queryKey: ['order', id],     queryFn: () => api.getOrder(id),   });      const processOrder = useMutation({     mutationFn: (action) => api.processOrder(id, action),     onSuccess: () => {       queryClient.invalidateQueries(['order', id]);       queryClient.invalidateQueries(['orders']);     },   });    return (     <ScrollView>       {/* Header con n√∫mero y estado */}       <View style={styles.header}>         <Text style={styles.orderNumber}>{order?.orderNumber}</Text>         <StatusBadge status={order?.status} large />       </View>              {/* Alerta si es urgente */}       {order?.isUrgent && (         <Alert type="warning" message="Este pedido requiere atenci√≥n urgente" />       )}              {/* Info del cliente */}       <Card>         <Text style={styles.sectionTitle}>Cliente</Text>         <Text>{order?.customer.name}</Text>         <Text>{order?.customer.email}</Text>         <Text>{order?.customer.phone}</Text>         <Button           title="Contactar"           icon={<PhoneIcon />}           onPress={() => Linking.openURL(`tel:${order.customer.phone}`)}           variant="outline"           small         />       </Card>              {/* Productos */}       <Card>         <Text style={styles.sectionTitle}>Productos</Text>         {order?.items.map(item => (           <OrderItemRow             key={item.id}             item={item}             showLocation  // Ubicaci√≥n en almac√©n           />         ))}       </Card>              {/* Totales */}       <OrderTotals order={order} />              {/* Info de env√≠o o recogida */}       {order?.fulfillmentType === 'shipping' ? (         <ShippingCard order={order} />       ) : (         <PickupCard order={order} />       )}              {/* Notas */}       {order?.notes && (         <Card>           <Text style={styles.sectionTitle}>Notas del cliente</Text>           <Text>{order.notes}</Text>         </Card>       )}              {/* Historial de estados */}       <Card>         <Text style={styles.sectionTitle}>Historial</Text>         <OrderTimeline events={order?.statusHistory} />       </Card>              {/* Acciones seg√∫n estado */}       <View style={styles.actions}>         <OrderActions           order={order}           onProcess={processOrder.mutate}           isLoading={processOrder.isLoading}         />       </View>     </ScrollView>   ); }  // Componente de acciones seg√∫n estado function OrderActions({ order, onProcess, isLoading }) {   switch (order.status) {     case 'confirmed':       return (         <Button           title="Empezar preparaci√≥n"           onPress={() => onProcess('process')}           loading={isLoading}         />       );          case 'processing':       if (order.fulfillmentType === 'click_collect') {         return (           <Button             title="Marcar listo para recoger"             onPress={() => onProcess('ready_pickup')}             loading={isLoading}           />         );       }       return (         <>           <Button             title="Generar etiqueta de env√≠o"             onPress={() => router.push(`/order/${order.id}/ship`)}           />           <Button             title="Marcar como enviado"             onPress={() => onProcess('ship')}             loading={isLoading}           />         </>       );          case 'ready_pickup':       return (         <Button           title="Escanear c√≥digo de recogida"           icon={<ScanIcon />}           onPress={() => router.push('/pickup/scan')}         />       );          default:       return null;   } }
‚ÄÉ
3.6 Esc√°ner Click & Collect
// app/pickup/scan.tsx - C&C Scanner import { CameraView, useCameraPermissions } from 'expo-camera'; import { Audio } from 'expo-av';  export default function PickupScannerScreen() {   const [permission, requestPermission] = useCameraPermissions();   const [scanned, setScanned] = useState(false);   const [result, setResult] = useState(null);      const verifyPickup = useMutation({     mutationFn: (code) => api.verifyPickupCode(code),     onSuccess: (data) => {       playSuccessSound();       setResult({ success: true, order: data.order });     },     onError: (error) => {       playErrorSound();       setResult({ success: false, error: error.message });     },   });      const confirmPickup = useMutation({     mutationFn: (orderId) => api.confirmPickup(orderId),     onSuccess: () => {       haptics.notificationSuccess();       router.replace('/pickup/success');     },   });      const handleBarCodeScanned = ({ type, data }) => {     if (scanned) return;     setScanned(true);     haptics.impactMedium();     verifyPickup.mutate(data);   };    if (!permission?.granted) {     return (       <View style={styles.permissionContainer}>         <Text>Necesitamos acceso a la c√°mara para escanear c√≥digos</Text>         <Button title="Permitir c√°mara" onPress={requestPermission} />       </View>     );   }    return (     <View style={styles.container}>       {/* C√°mara */}       <CameraView         style={styles.camera}         facing="back"         barcodeScannerSettings={{           barcodeTypes: ['qr'],         }}         onBarcodeScanned={scanned ? undefined : handleBarCodeScanned}       >         {/* Overlay con marco */}         <View style={styles.overlay}>           <View style={styles.scanFrame} />           <Text style={styles.hint}>Escanea el QR del cliente</Text>         </View>       </CameraView>              {/* Input manual */}       <View style={styles.manualInput}>         <TextInput           placeholder="O introduce el c√≥digo manualmente"           style={styles.codeInput}           onSubmitEditing={(e) => verifyPickup.mutate(e.nativeEvent.text)}           autoCapitalize="characters"         />       </View>              {/* Modal de resultado */}       <Modal visible={result !== null} animationType="slide">         {result?.success ? (           <View style={styles.successModal}>             <CheckCircleIcon size={64} color="green" />             <Text style={styles.successTitle}>¬°C√≥digo v√°lido!</Text>                          <Card style={styles.orderCard}>               <Text style={styles.orderNumber}>                 Pedido {result.order.orderNumber}               </Text>               <Text>{result.order.customer.name}</Text>               <Text>{result.order.items.length} producto(s)</Text>               <Text style={styles.total}>                 {formatCurrency(result.order.total)}               </Text>             </Card>                          <View style={styles.orderItems}>               {result.order.items.map(item => (                 <OrderItemRow key={item.id} item={item} />               ))}             </View>                          <Button               title="Confirmar entrega"               onPress={() => confirmPickup.mutate(result.order.id)}               loading={confirmPickup.isLoading}               style={styles.confirmButton}             />                          <Button               title="Cancelar"               variant="ghost"               onPress={() => {                 setResult(null);                 setScanned(false);               }}             />           </View>         ) : (           <View style={styles.errorModal}>             <XCircleIcon size={64} color="red" />             <Text style={styles.errorTitle}>C√≥digo no v√°lido</Text>             <Text style={styles.errorMessage}>{result?.error}</Text>             <Button               title="Intentar de nuevo"               onPress={() => {                 setResult(null);                 setScanned(false);               }}             />           </View>         )}       </Modal>     </View>   ); }
‚ÄÉ
3.7 Ajuste R√°pido de Stock
// app/inventory/adjust.tsx - Quick Stock Adjust with Scanner export default function StockAdjustScreen() {   const [product, setProduct] = useState(null);   const [adjustment, setAdjustment] = useState(0);      const adjustStock = useMutation({     mutationFn: (data) => api.adjustStock(data),     onSuccess: () => {       haptics.notificationSuccess();       setProduct(null);       setAdjustment(0);     },   });      const handleBarCodeScanned = async ({ data }) => {     haptics.impactMedium();     const found = await api.findProductByBarcode(data);     if (found) {       setProduct(found);     } else {       Alert.alert('No encontrado', 'Este c√≥digo no corresponde a ning√∫n producto');     }   };    return (     <View style={styles.container}>       {!product ? (         // Modo esc√°ner         <>           <CameraView             style={styles.camera}             barcodeScannerSettings={{               barcodeTypes: ['ean13', 'ean8', 'upc_a', 'upc_e', 'code128'],             }}             onBarcodeScanned={handleBarCodeScanned}           >             <View style={styles.overlay}>               <View style={styles.scanFrame} />               <Text style={styles.hint}>Escanea el c√≥digo de barras del producto</Text>             </View>           </CameraView>                      <Button             title="Buscar por nombre"             icon={<SearchIcon />}             onPress={() => router.push('/inventory/search')}             variant="outline"           />         </>       ) : (         // Modo ajuste         <ScrollView>           <Card style={styles.productCard}>             <Image source={{ uri: product.image }} style={styles.productImage} />             <View style={styles.productInfo}>               <Text style={styles.productTitle}>{product.title}</Text>               {product.sku && <Text style={styles.sku}>SKU: {product.sku}</Text>}               {product.barcode && <Text style={styles.barcode}>EAN: {product.barcode}</Text>}             </View>           </Card>                      {/* Stock actual */}           <Card style={styles.stockCard}>             <Text style={styles.label}>Stock actual</Text>             <Text style={styles.stockValue}>{product.stock} unidades</Text>           </Card>                      {/* Selector de ajuste */}           <Card style={styles.adjustCard}>             <Text style={styles.label}>Ajustar stock</Text>             <View style={styles.adjustControls}>               <TouchableOpacity                 style={styles.adjustButton}                 onPress={() => setAdjustment(a => a - 1)}               >                 <MinusIcon size={24} />               </TouchableOpacity>                              <TextInput                 style={styles.adjustInput}                 value={adjustment.toString()}                 onChangeText={(t) => setAdjustment(parseInt(t) || 0)}                 keyboardType="number-pad"               />                              <TouchableOpacity                 style={styles.adjustButton}                 onPress={() => setAdjustment(a => a + 1)}               >                 <PlusIcon size={24} />               </TouchableOpacity>             </View>                          {/* Preview del nuevo stock */}             <View style={styles.preview}>               <Text>Nuevo stock: </Text>               <Text style={[                 styles.newStock,                 adjustment > 0 && styles.positive,                 adjustment < 0 && styles.negative,               ]}>                 {product.stock + adjustment}               </Text>             </View>           </Card>                      {/* Motivo */}           <Card>             <Text style={styles.label}>Motivo del ajuste</Text>             <Picker               selectedValue={reason}               onValueChange={setReason}             >               <Picker.Item label="Recuento f√≠sico" value="count" />               <Picker.Item label="Recepci√≥n de mercanc√≠a" value="receive" />               <Picker.Item label="Devoluci√≥n" value="return" />               <Picker.Item label="Rotura/P√©rdida" value="shrinkage" />               <Picker.Item label="Otro" value="other" />             </Picker>           </Card>                      {/* Acciones */}           <View style={styles.actions}>             <Button               title="Confirmar ajuste"               onPress={() => adjustStock.mutate({                 productId: product.id,                 adjustment,                 reason,               })}               loading={adjustStock.isLoading}               disabled={adjustment === 0}             />             <Button               title="Escanear otro"               variant="outline"               onPress={() => setProduct(null)}             />           </View>         </ScrollView>       )}     </View>   ); }
‚ÄÉ
4. Funcionalidades Compartidas
4.1 Push Notifications
// services/notifications.ts import * as Notifications from 'expo-notifications'; import * as Device from 'expo-device'; import { Platform } from 'react-native';  export async function registerForPushNotifications() {   if (!Device.isDevice) {     console.log('Push notifications require a physical device');     return null;   }      // Pedir permisos   const { status: existingStatus } = await Notifications.getPermissionsAsync();   let finalStatus = existingStatus;      if (existingStatus !== 'granted') {     const { status } = await Notifications.requestPermissionsAsync();     finalStatus = status;   }      if (finalStatus !== 'granted') {     return null;   }      // Obtener token   const token = await Notifications.getExpoPushTokenAsync({     projectId: Constants.expoConfig?.extra?.eas?.projectId,   });      // Configurar canal para Android   if (Platform.OS === 'android') {     await Notifications.setNotificationChannelAsync('orders', {       name: 'Pedidos',       importance: Notifications.AndroidImportance.HIGH,       sound: 'order.wav',       vibrationPattern: [0, 250, 250, 250],     });          await Notifications.setNotificationChannelAsync('marketing', {       name: 'Promociones',       importance: Notifications.AndroidImportance.DEFAULT,     });   }      return token.data; }  // Hook para manejar notificaciones export function useNotifications() {   const notificationListener = useRef<Subscription>();   const responseListener = useRef<Subscription>();      useEffect(() => {     // Listener para notificaciones recibidas con app abierta     notificationListener.current = Notifications.addNotificationReceivedListener(       (notification) => {         // Mostrar toast o actualizar UI         const { title, body, data } = notification.request.content;         showToast(title, body);                  // Refetch datos si es relevante         if (data.type === 'new_order') {           queryClient.invalidateQueries(['orders']);           queryClient.invalidateQueries(['dashboard']);         }       }     );          // Listener para tap en notificaci√≥n     responseListener.current = Notifications.addNotificationResponseReceivedListener(       (response) => {         const { data } = response.notification.request.content;                  // Navegar seg√∫n tipo         switch (data.type) {           case 'order_status':             router.push(`/order/${data.orderId}`);             break;           case 'new_review':             router.push(`/reviews/${data.reviewId}`);             break;           case 'flash_offer':             router.push(`/product/${data.productId}`);             break;         }       }     );          return () => {       notificationListener.current?.remove();       responseListener.current?.remove();     };   }, []); }
‚ÄÉ
4.2 Autenticaci√≥n y Biometr√≠a
// services/auth.ts import * as LocalAuthentication from 'expo-local-authentication'; import * as SecureStore from 'expo-secure-store';  export async function checkBiometricSupport() {   const compatible = await LocalAuthentication.hasHardwareAsync();   const enrolled = await LocalAuthentication.isEnrolledAsync();   const types = await LocalAuthentication.supportedAuthenticationTypesAsync();      return {     supported: compatible && enrolled,     types: types.map(t => {       switch (t) {         case LocalAuthentication.AuthenticationType.FINGERPRINT:           return 'fingerprint';         case LocalAuthentication.AuthenticationType.FACIAL_RECOGNITION:           return 'face';         case LocalAuthentication.AuthenticationType.IRIS:           return 'iris';         default:           return 'unknown';       }     }),   }; }  export async function authenticateWithBiometrics() {   const result = await LocalAuthentication.authenticateAsync({     promptMessage: 'Accede a tu cuenta',     cancelLabel: 'Usar contrase√±a',     disableDeviceFallback: true,   });      return result.success; }  // Hook de autenticaci√≥n export function useAuth() {   const [user, setUser] = useState(null);   const [isLoading, setIsLoading] = useState(true);      useEffect(() => {     checkAuthState();   }, []);      const checkAuthState = async () => {     const token = await SecureStore.getItemAsync('auth_token');     if (token) {       try {         const userData = await api.getMe();         setUser(userData);       } catch {         await SecureStore.deleteItemAsync('auth_token');       }     }     setIsLoading(false);   };      const login = async (email: string, password: string) => {     const { token, user } = await api.login(email, password);     await SecureStore.setItemAsync('auth_token', token);     setUser(user);          // Registrar push token     const pushToken = await registerForPushNotifications();     if (pushToken) {       await api.registerPushToken(pushToken);     }   };      const loginWithBiometrics = async () => {     const credentials = await SecureStore.getItemAsync('biometric_credentials');     if (!credentials) throw new Error('No biometric credentials stored');          const success = await authenticateWithBiometrics();     if (!success) throw new Error('Biometric authentication failed');          const { email, password } = JSON.parse(credentials);     return login(email, password);   };      const logout = async () => {     await api.logout();     await SecureStore.deleteItemAsync('auth_token');     setUser(null);   };      return { user, isLoading, login, loginWithBiometrics, logout }; }
‚ÄÉ
4.3 Offline Support
// services/offline.ts import NetInfo from '@react-native-community/netinfo'; import { MMKV } from 'react-native-mmkv';  const storage = new MMKV();  // Hook para detectar conectividad export function useNetworkStatus() {   const [isConnected, setIsConnected] = useState(true);      useEffect(() => {     const unsubscribe = NetInfo.addEventListener(state => {       setIsConnected(state.isConnected ?? true);     });          return () => unsubscribe();   }, []);      return isConnected; }  // Cache de datos cr√≠ticos para offline export class OfflineCache {   // Guardar pedidos pendientes de procesar   static queueAction(action: OfflineAction) {     const queue = this.getQueue();     queue.push({ ...action, timestamp: Date.now() });     storage.set('offline_queue', JSON.stringify(queue));   }      static getQueue(): OfflineAction[] {     const data = storage.getString('offline_queue');     return data ? JSON.parse(data) : [];   }      static clearQueue() {     storage.delete('offline_queue');   }      // Procesar cola cuando vuelve conexi√≥n   static async processQueue() {     const queue = this.getQueue();     const failed: OfflineAction[] = [];          for (const action of queue) {       try {         await this.executeAction(action);       } catch {         failed.push(action);       }     }          storage.set('offline_queue', JSON.stringify(failed));     return { processed: queue.length - failed.length, failed: failed.length };   }      static async executeAction(action: OfflineAction) {     switch (action.type) {       case 'confirm_pickup':         return api.confirmPickup(action.orderId);       case 'adjust_stock':         return api.adjustStock(action.productId, action.adjustment);       case 'process_order':         return api.processOrder(action.orderId, action.status);     }   }      // Cache de productos para esc√°ner offline   static cacheProducts(products: Product[]) {     const map = new Map();     products.forEach(p => {       if (p.barcode) map.set(p.barcode, p);     });     storage.set('products_cache', JSON.stringify(Array.from(map.entries())));   }      static findProductByBarcode(barcode: string): Product | null {     const data = storage.getString('products_cache');     if (!data) return null;     const map = new Map(JSON.parse(data));     return map.get(barcode) || null;   } }  // Auto-sync cuando vuelve conexi√≥n export function useOfflineSync() {   const isConnected = useNetworkStatus();   const previouslyConnected = useRef(isConnected);      useEffect(() => {     if (isConnected && !previouslyConnected.current) {       // Reconectado!       OfflineCache.processQueue().then(result => {         if (result.processed > 0) {           showToast(`${result.processed} acciones sincronizadas`);         }       });     }     previouslyConnected.current = isConnected;   }, [isConnected]); }
‚ÄÉ
5. Deep Linking y Universal Links
5.1 Configuraci√≥n de Links
// app.json - Expo Config {   "expo": {     "scheme": "comercioconecta",     "web": {       "bundler": "metro"     },     "ios": {       "bundleIdentifier": "es.comercioconecta.app",       "associatedDomains": [         "applinks:comercioconecta.es",         "applinks:*.comercioconecta.es"       ]     },     "android": {       "package": "es.comercioconecta.app",       "intentFilters": [         {           "action": "VIEW",           "autoVerify": true,           "data": [             {               "scheme": "https",               "host": "comercioconecta.es",               "pathPrefix": "/producto"             },             {               "scheme": "https",               "host": "comercioconecta.es",               "pathPrefix": "/pedido"             }           ],           "category": ["BROWSABLE", "DEFAULT"]         }       ]     }   } }
5.2 Rutas Soportadas
URL	App Route	Descripci√≥n
comercioconecta.es/producto/:id	/product/:id	Abrir detalle de producto
comercioconecta.es/pedido/:id	/order/:id	Ver pedido (requiere auth)
comercioconecta.es/tienda/:id	/merchant/:id	Perfil de comercio
comercioconecta.es/categoria/:slug	/category/:slug	Listado de categor√≠a
comercioconecta.es/oferta/:id	/offer/:id	Flash Offer
comercioconecta.es/tracking/:id	/order/:id/tracking	Tracking de pedido
comercioconecta://cart	/(tabs)/cart	Abrir carrito
comercioconecta://scan	/scanner	Abrir esc√°ner
comercioconecta://account	/(tabs)/account	Mi cuenta
‚ÄÉ
6. Publicaci√≥n en Stores
6.1 Requisitos App Store (iOS)
Elemento	Especificaci√≥n	Notas
App Name	ComercioConecta / ComercioConecta Business	30 chars max
Subtitle	Compra en comercios locales	30 chars max
Description	Descripci√≥n completa de funcionalidades	4000 chars max
Keywords	compras, local, comercio, tienda, barrio	100 chars max
Screenshots	6.7" (iPhone 15 Pro Max), 6.5" (iPhone 11 Pro Max)	6 screenshots min
App Icon	1024x1024 sin transparencia	PNG, no alpha
Privacy Policy URL	https://comercioconecta.es/privacidad	Requerido
Support URL	https://comercioconecta.es/soporte	Requerido
Age Rating	4+	Sin contenido restringido
Category	Shopping	Primary category
6.2 Requisitos Google Play (Android)
Elemento	Especificaci√≥n	Notas
App Name	ComercioConecta / ComercioConecta Business	50 chars max
Short Description	Compra en comercios de tu barrio	80 chars max
Full Description	Descripci√≥n completa	4000 chars max
Feature Graphic	1024x500 px	Requerido
Screenshots	Phone + Tablet (7" y 10")	Min 2, max 8
App Icon	512x512 px	PNG con alpha permitido
Privacy Policy	URL accesible	Requerido
Content Rating	IARC questionnaire	Todos
Category	Shopping	Primary category
Target Audience	Adults	18+
‚ÄÉ
7. Roadmap de Implementaci√≥n
Sprint	Timeline	Entregables	Dependencias
Sprint 1	Semana 1-2	Setup Expo. Navegaci√≥n. Auth. Push notifications.	Backend APIs
Sprint 2	Semana 3-4	Cliente: Home, B√∫squeda, Producto, Carrito.	Sprint 1
Sprint 3	Semana 5-6	Cliente: Checkout completo, Apple/Google Pay.	Sprint 2
Sprint 4	Semana 7-8	Cliente: Pedidos, Tracking, C&C pickup.	Sprint 3
Sprint 5	Semana 9-10	Business: Dashboard, Pedidos, Esc√°ner C&C.	Sprint 4
Sprint 6	Semana 11-12	Business: Inventario, Notificaciones. QA. Publicaci√≥n.	Sprint 5
7.1 M√©tricas de √âxito
M√©trica	Objetivo	Medici√≥n
App Store Rating	>4.5‚òÖ	Stores
Crash-free users	>99.5%	Crashlytics
Daily Active Users (DAU)	>1000 (6 meses)	Analytics
Conversi√≥n m√≥vil	>3%	Analytics
Push opt-in rate	>60%	Analytics
Session duration	>3 min	Analytics
7.2 Dependencias
‚Ä¢ Expo SDK 50+ y EAS Build
‚Ä¢ Cuenta Apple Developer ($99/a√±o)
‚Ä¢ Cuenta Google Play Console ($25 una vez)
‚Ä¢ APIs backend completas
‚Ä¢ Stripe SDK para pagos nativos
‚Ä¢ Firebase para Push y Analytics
--- Fin del Documento ---
77_ComercioConecta_Mobile_App_v1.docx | Jaraba Impact Platform | Enero 2026
