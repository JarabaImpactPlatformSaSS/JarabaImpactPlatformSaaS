<?php

declare(strict_types=1);

/**
 * @file
 * Install, update, and uninstall functions for jaraba_content_hub.
 */

/**
 * Install canvas_data, rendered_html, and layout_mode fields for ContentArticle.
 *
 * Estos campos soportan la integración del Canvas Editor GrapesJS
 * en el Content Hub, permitiendo a los autores componer artículos
 * con el editor visual drag-and-drop.
 *
 * - layout_mode: 'legacy' (textarea clásico) o 'canvas' (editor visual).
 * - canvas_data: JSON con el estado completo del GrapesJS editor.
 * - rendered_html: HTML sanitizado exportado para la vista pública.
 */
function jaraba_content_hub_update_10001(&$sandbox) {
  $entity_type_id = 'content_article';
  $fields_to_install = ['layout_mode', 'canvas_data', 'rendered_html'];

  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');

  // Get field storage definitions from the entity class.
  $field_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);

  $installed = [];
  foreach ($fields_to_install as $field_name) {
    if (isset($field_definitions[$field_name])) {
      try {
        $entity_definition_update_manager->installFieldStorageDefinition(
          $field_name,
          $entity_type_id,
          'jaraba_content_hub',
          $field_definitions[$field_name]
        );
        $installed[] = $field_name;
      }
      catch (\Exception $e) {
        \Drupal::logger('jaraba_content_hub')->error(
          'Error installing field @field for @entity: @message',
          [
            '@field' => $field_name,
            '@entity' => $entity_type_id,
            '@message' => $e->getMessage(),
          ]
        );
      }
    }
    else {
      \Drupal::logger('jaraba_content_hub')->warning(
        'Field @field not found in @entity field definitions.',
        ['@field' => $field_name, '@entity' => $entity_type_id]
      );
    }
  }

  if (!empty($installed)) {
    return t('Installed Canvas Editor fields for ContentArticle: @fields', [
      '@fields' => implode(', ', $installed),
    ]);
  }

  return t('No Canvas Editor fields needed installation for ContentArticle.');
}

/**
 * Generate slugs for existing ContentArticle entities missing slugs.
 *
 * Iterates all articles and generates unique slugs from their titles.
 * Uses batch processing via $sandbox for large datasets.
 */
function jaraba_content_hub_update_10002(&$sandbox) {
  $storage = \Drupal::entityTypeManager()->getStorage('content_article');

  if (!isset($sandbox['total'])) {
    // Count articles without slugs.
    $ids = $storage->getQuery()
      ->accessCheck(FALSE)
      ->notExists('slug')
      ->execute();

    // Also include articles with empty slug.
    $empty_ids = $storage->getQuery()
      ->accessCheck(FALSE)
      ->condition('slug', '')
      ->execute();

    $all_ids = array_unique(array_merge(array_values($ids), array_values($empty_ids)));
    $sandbox['ids'] = array_values($all_ids);
    $sandbox['total'] = count($all_ids);
    $sandbox['current'] = 0;
    $sandbox['generated'] = 0;
  }

  if ($sandbox['total'] === 0) {
    $sandbox['#finished'] = 1;
    return t('All ContentArticle entities already have slugs.');
  }

  // Process 50 articles per batch.
  $batch_size = 50;
  $batch_ids = array_slice($sandbox['ids'], $sandbox['current'], $batch_size);

  foreach ($batch_ids as $id) {
    $article = $storage->load($id);
    if (!$article) {
      $sandbox['current']++;
      continue;
    }

    $slug = $article->get('slug')->value ?? '';
    if (!empty($slug)) {
      $sandbox['current']++;
      continue;
    }

    $title = $article->label() ?? 'article-' . $article->id();

    if (\Drupal::hasService('pathauto.alias_cleaner')) {
      $base_slug = \Drupal::service('pathauto.alias_cleaner')->cleanString($title);
    }
    else {
      $base_slug = _jaraba_content_hub_slugify($title);
    }

    $unique_slug = _jaraba_content_hub_ensure_unique_slug($base_slug, $article->id());
    $article->set('slug', $unique_slug);
    $article->save();

    $sandbox['current']++;
    $sandbox['generated']++;
  }

  $sandbox['#finished'] = $sandbox['current'] >= $sandbox['total'] ? 1 : $sandbox['current'] / $sandbox['total'];

  if ($sandbox['#finished'] >= 1) {
    return t('Generated slugs for @count articles.', ['@count' => $sandbox['generated']]);
  }
}

/**
 * GAP-AUD-017: Install tenant_id field for ContentArticle entity.
 *
 * Enables multi-tenant isolation per TENANT-ISOLATION-ACCESS-001.
 * Existing articles get tenant_id = 0 (backward compatible).
 */
function jaraba_content_hub_update_10003(&$sandbox) {
  $entity_type_id = 'content_article';
  $field_name = 'tenant_id';

  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');

  $field_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);

  if (isset($field_definitions[$field_name])) {
    try {
      $entity_definition_update_manager->installFieldStorageDefinition(
        $field_name,
        $entity_type_id,
        'jaraba_content_hub',
        $field_definitions[$field_name]
      );
      return t('GAP-AUD-017: Installed tenant_id field for ContentArticle.');
    }
    catch (\Exception $e) {
      \Drupal::logger('jaraba_content_hub')->error(
        'Error installing tenant_id for @entity: @message',
        ['@entity' => $entity_type_id, '@message' => $e->getMessage()]
      );
    }
  }

  return t('GAP-AUD-017: tenant_id field not found or already installed for ContentArticle.');
}

/**
 * GAP-AUD-017: Install tenant_id field for ContentCategory entity.
 *
 * Enables multi-tenant isolation for categories.
 * Existing categories get tenant_id = 0 (backward compatible).
 */
function jaraba_content_hub_update_10004(&$sandbox) {
  $entity_type_id = 'content_category';
  $field_name = 'tenant_id';

  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');

  $field_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);

  if (isset($field_definitions[$field_name])) {
    try {
      $entity_definition_update_manager->installFieldStorageDefinition(
        $field_name,
        $entity_type_id,
        'jaraba_content_hub',
        $field_definitions[$field_name]
      );
      return t('GAP-AUD-017: Installed tenant_id field for ContentCategory.');
    }
    catch (\Exception $e) {
      \Drupal::logger('jaraba_content_hub')->error(
        'Error installing tenant_id for @entity: @message',
        ['@entity' => $entity_type_id, '@message' => $e->getMessage()]
      );
    }
  }

  return t('GAP-AUD-017: tenant_id field not found or already installed for ContentCategory.');
}

/**
 * Install new backported fields for ContentArticle.
 *
 * Adds tags, featured_image_alt, is_featured, views_count, schema_type,
 * og_image, content_author, vertical, scheduled_at.
 * Per DRUPAL-ENTUP-001: uses installFieldStorageDefinition().
 */
function jaraba_content_hub_update_10005(&$sandbox) {
  $entity_type_id = 'content_article';
  $fields_to_install = [
    'tags', 'featured_image_alt', 'is_featured', 'views_count',
    'schema_type', 'og_image', 'content_author', 'vertical', 'scheduled_at',
  ];
  return _jaraba_content_hub_install_fields($entity_type_id, $fields_to_install);
}

/**
 * Install new fields for ContentCategory.
 *
 * Adds featured_image, meta_title, meta_description, is_active, posts_count.
 */
function jaraba_content_hub_update_10006(&$sandbox) {
  $entity_type_id = 'content_category';
  $fields_to_install = [
    'featured_image', 'meta_title', 'meta_description', 'is_active', 'posts_count',
  ];
  return _jaraba_content_hub_install_fields($entity_type_id, $fields_to_install);
}

/**
 * Migrate ContentArticle tenant_id from integer to entity_reference.
 *
 * TENANT-BRIDGE-001: Reads old integer values, drops the field,
 * reinstalls as entity_reference to group, restores data as target_id.
 */
function jaraba_content_hub_update_10007(&$sandbox) {
  return _jaraba_content_hub_migrate_tenant_field('content_article');
}

/**
 * Migrate ContentCategory tenant_id from integer to entity_reference.
 */
function jaraba_content_hub_update_10008(&$sandbox) {
  return _jaraba_content_hub_migrate_tenant_field('content_category');
}

/**
 * Install ContentAuthor entity type schema.
 */
function jaraba_content_hub_update_10009(&$sandbox) {
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  $entity_type = $entity_type_manager->getDefinition('content_author');
  $entity_definition_update_manager->installEntityType($entity_type);

  return t('Installed ContentAuthor entity type and all field storage definitions.');
}

/**
 * Install ContentComment entity type schema.
 *
 * REV-PHASE2: Sistema de comentarios con threading para artículos.
 * Entidad con ReviewableEntityTrait para moderación y social proof.
 */
function jaraba_content_hub_update_10010(&$sandbox) {
  $entity_type_manager = \Drupal::entityTypeManager();
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();

  try {
    $entity_type = $entity_type_manager->getDefinition('content_comment');
    $entity_definition_update_manager->installEntityType($entity_type);
    return t('Installed ContentComment entity type and all field storage definitions.');
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_content_hub')->error(
      'Error installing ContentComment entity type: @message',
      ['@message' => $e->getMessage()]
    );
    return t('Error installing ContentComment: @message', ['@message' => $e->getMessage()]);
  }
}

/**
 * Helper: Install multiple fields for an entity type.
 *
 * @param string $entity_type_id
 *   The entity type ID.
 * @param array $fields_to_install
 *   Array of field names to install.
 *
 * @return string
 *   Result message.
 */
function _jaraba_content_hub_install_fields(string $entity_type_id, array $fields_to_install): string {
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');
  $field_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);

  $installed = [];
  foreach ($fields_to_install as $field_name) {
    if (isset($field_definitions[$field_name])) {
      try {
        $entity_definition_update_manager->installFieldStorageDefinition(
          $field_name,
          $entity_type_id,
          'jaraba_content_hub',
          $field_definitions[$field_name]
        );
        $installed[] = $field_name;
      }
      catch (\Exception $e) {
        \Drupal::logger('jaraba_content_hub')->error(
          'Error installing field @field for @entity: @message',
          ['@field' => $field_name, '@entity' => $entity_type_id, '@message' => $e->getMessage()]
        );
      }
    }
  }

  if (!empty($installed)) {
    return (string) t('Installed fields for @entity: @fields', [
      '@entity' => $entity_type_id,
      '@fields' => implode(', ', $installed),
    ]);
  }

  return (string) t('No fields needed installation for @entity.', ['@entity' => $entity_type_id]);
}

/**
 * Helper: Migrate tenant_id from integer to entity_reference.
 *
 * Strategy:
 * 1. Read old integer values into memory.
 * 2. Uninstall the old integer field storage.
 * 3. Install new entity_reference field storage.
 * 4. Restore values as target_id (only non-zero values).
 *
 * @param string $entity_type_id
 *   The entity type ID.
 *
 * @return string
 *   Result message.
 */
function _jaraba_content_hub_migrate_tenant_field(string $entity_type_id): string {
  $database = \Drupal::database();
  $entity_definition_update_manager = \Drupal::entityDefinitionUpdateManager();
  $entity_field_manager = \Drupal::service('entity_field.manager');

  $data_table = $entity_type_id . '_field_data';

  // 1. Read old integer values.
  $old_values = [];
  try {
    if ($database->schema()->fieldExists($data_table, 'tenant_id')) {
      $rows = $database->select($data_table, 't')
        ->fields('t', ['id', 'tenant_id'])
        ->condition('tenant_id', 0, '>')
        ->execute();
      foreach ($rows as $row) {
        $old_values[$row->id] = (int) $row->tenant_id;
      }
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_content_hub')->warning(
      'Could not read old tenant_id values for @entity: @error',
      ['@entity' => $entity_type_id, '@error' => $e->getMessage()]
    );
  }

  // 2. Uninstall old field storage.
  $existing_storage = $entity_definition_update_manager->getFieldStorageDefinition('tenant_id', $entity_type_id);
  if ($existing_storage) {
    $entity_definition_update_manager->uninstallFieldStorageDefinition($existing_storage);
  }

  // 3. Install new entity_reference field storage.
  // Clear cached definitions to pick up the new definition from code.
  \Drupal::service('entity_field.manager')->clearCachedFieldDefinitions();
  $field_definitions = $entity_field_manager->getFieldStorageDefinitions($entity_type_id);
  if (isset($field_definitions['tenant_id'])) {
    $entity_definition_update_manager->installFieldStorageDefinition(
      'tenant_id',
      $entity_type_id,
      'jaraba_content_hub',
      $field_definitions['tenant_id']
    );
  }

  // 4. Restore values as target_id.
  $restored = 0;
  foreach ($old_values as $id => $tenant_id) {
    try {
      $database->update($data_table)
        ->fields(['tenant_id' => $tenant_id])
        ->condition('id', $id)
        ->execute();
      $restored++;
    }
    catch (\Exception $e) {
      \Drupal::logger('jaraba_content_hub')->warning(
        'Could not restore tenant_id for @entity @id: @error',
        ['@entity' => $entity_type_id, '@id' => $id, '@error' => $e->getMessage()]
      );
    }
  }

  return (string) t('Migrated tenant_id to entity_reference for @entity. Restored @count values.', [
    '@entity' => $entity_type_id,
    '@count' => $restored,
  ]);
}
