<?php

/**
 * @file
 * Jaraba Commerce module - Integración Commerce + Multi-tenancy.
 *
 * Este módulo proporciona:
 * - Auto-creación de Commerce Store por Tenant
 * - Campos GEO (field_ai_summary) para productos
 * - Integración con el sistema de multi-tenancy
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\ecosistema_jaraba_core\Entity\TenantInterface;

/**
 * Implements hook_entity_insert().
 *
 * Cuando se crea un nuevo Tenant, crea automáticamente una Commerce Store.
 */
function jaraba_commerce_entity_insert(EntityInterface $entity) {
  if ($entity->getEntityTypeId() !== 'tenant') {
    return;
  }

  if (!$entity instanceof TenantInterface) {
    return;
  }

  // Verificar que Commerce está instalado
  if (!\Drupal::moduleHandler()->moduleExists('commerce_store')) {
    return;
  }

  // Crear la Store para el nuevo Tenant
  try {
    /** @var \Drupal\jaraba_commerce\EventSubscriber\TenantStoreSubscriber $storeSubscriber */
    $storeSubscriber = \Drupal::service('jaraba_commerce.tenant_store_subscriber');
    $store = $storeSubscriber->createStoreForTenant($entity);

    if ($store) {
      \Drupal::messenger()->addStatus(t(
        'Tienda Commerce creada automáticamente: @store',
        ['@store' => $store->getName()]
      ));
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_commerce')->error(
      'Error en hook_entity_insert para Tenant: @error',
      ['@error' => $e->getMessage()]
    );
  }
}

/**
 * Implements hook_entity_bundle_field_info().
 *
 * Añade el campo field_ai_summary a los productos Commerce para Answer Capsules.
 */
function jaraba_commerce_entity_bundle_field_info(\Drupal\Core\Entity\EntityTypeInterface $entity_type, $bundle, array $base_field_definitions) {
  $fields = [];

  // Solo para commerce_product
  if ($entity_type->id() !== 'commerce_product') {
    return $fields;
  }

  // Campo field_ai_summary ya se añade vía config - este hook es para campos base
  // Lo dejamos preparado por si se necesita en el futuro
  
  return $fields;
}

/**
 * Implements hook_preprocess_HOOK() for commerce_product.
 *
 * Inyecta Schema.org Product JSON-LD automáticamente en páginas de producto.
 */
function jaraba_commerce_preprocess_commerce_product(array &$variables): void {
  $product = $variables['product_entity'] ?? NULL;
  if (!$product) {
    return;
  }

  // Preparar datos para Schema.org.
  $productData = [
    'name' => $product->getTitle(),
    'description' => $product->get('body')->value ?? '',
  ];

  // URL del producto.
  try {
    $productData['url'] = $product->toUrl('canonical', ['absolute' => TRUE])->toString();
  }
  catch (\Exception $e) {
    // URL no disponible.
  }

  // Imagen.
  if ($product->hasField('field_product_images') && !$product->get('field_product_images')->isEmpty()) {
    $image = $product->get('field_product_images')->first();
    if ($image && $image->entity) {
      $productData['image'] = \Drupal::service('file_url_generator')->generateAbsoluteString($image->entity->getFileUri());
    }
  } elseif ($product->hasField('field_image') && !$product->get('field_image')->isEmpty()) {
    $image = $product->get('field_image')->first();
    if ($image && $image->entity) {
      $productData['image'] = \Drupal::service('file_url_generator')->generateAbsoluteString($image->entity->getFileUri());
    }
  }

  // SKU (del primer variation).
  $variations = $product->getVariations();
  if (!empty($variations)) {
    $firstVariation = reset($variations);
    if ($firstVariation) {
      $productData['sku'] = $firstVariation->getSku();
      
      // Precio.
      $price = $firstVariation->getPrice();
      if ($price) {
        $productData['price'] = $price->getNumber();
        $productData['currency'] = $price->getCurrencyCode();
      }
    }
  }

  // Marca (campo personalizado si existe).
  if ($product->hasField('field_brand') && !$product->get('field_brand')->isEmpty()) {
    $productData['brand'] = $product->get('field_brand')->entity->label() ?? $product->get('field_brand')->value;
  }

  // Categorías.
  if ($product->hasField('field_product_category') && !$product->get('field_product_category')->isEmpty()) {
    $categories = [];
    foreach ($product->get('field_product_category') as $term) {
      if ($term->entity) {
        $categories[] = $term->entity->label();
      }
    }
    if (!empty($categories)) {
      $productData['category'] = implode(' > ', $categories);
    }
  }

  // Stock: consultar módulo commerce_stock, campo field_stock_quantity o variation.
  $productData['in_stock'] = _jaraba_commerce_resolve_stock($product, $variations);

  // Datos del tenant/vendedor.
  $tenant = [];
  try {
    if (\Drupal::hasService('jaraba_page_builder.tenant_resolver')) {
      $tenantEntity = \Drupal::service('jaraba_page_builder.tenant_resolver')->getCurrentTenant();
      if ($tenantEntity) {
        $tenant['name'] = $tenantEntity->label();
        if ($tenantEntity->hasField('field_website')) {
          $tenant['url'] = $tenantEntity->get('field_website')->value ?? '';
        }
      }
    }
  }
  catch (\Exception $e) {
    // Usar valores por defecto.
  }

  // Generar Schema.org JSON-LD.
  try {
    if (\Drupal::hasService('jaraba_page_builder.schema_org')) {
      $schemaService = \Drupal::service('jaraba_page_builder.schema_org');
      $jsonLd = $schemaService->generateProductSchema($productData, $tenant);
      
      if (!empty($jsonLd)) {
        $variables['schema_org_json_ld'] = $schemaService->wrapInScriptTag($jsonLd);
        
        // Añadir al head de la página via #attached.
        $variables['#attached']['html_head'][] = [
          [
            '#type' => 'html_tag',
            '#tag' => 'script',
            '#attributes' => ['type' => 'application/ld+json'],
            '#value' => $jsonLd,
          ],
          'commerce_product_schema_org',
        ];
      }
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_commerce')->warning('Error generating Product schema: @error', [
      '@error' => $e->getMessage(),
    ]);
  }
}

/**
 * Determina disponibilidad de stock de un producto Commerce.
 *
 * Estrategia por prioridad:
 * 1. commerce_stock module: usa StockServiceManager si está instalado.
 * 2. field_stock_quantity en variaciones: suma de cantidades > 0.
 * 3. field_stock_quantity en producto: cantidad > 0.
 * 4. status del producto: si está publicado, asumimos disponible.
 *
 * @param \Drupal\commerce_product\Entity\ProductInterface $product
 *   El producto Commerce.
 * @param array $variations
 *   Variaciones ya cargadas del producto.
 *
 * @return bool
 *   TRUE si hay stock disponible.
 */
function _jaraba_commerce_resolve_stock($product, array $variations): bool {
  // 1. commerce_stock module con servicio StockServiceManager.
  if (\Drupal::moduleHandler()->moduleExists('commerce_stock')
      && \Drupal::hasService('commerce_stock.service_manager')) {
    try {
      $stockService = \Drupal::service('commerce_stock.service_manager');
      foreach ($variations as $variation) {
        $stock = $stockService->getStockLevel($variation);
        if ($stock > 0) {
          return TRUE;
        }
      }
      return !empty($variations) ? FALSE : TRUE;
    }
    catch (\Exception $e) {
      // Fallback al siguiente método.
    }
  }

  // 2. field_stock_quantity en variaciones.
  foreach ($variations as $variation) {
    if ($variation->hasField('field_stock_quantity')
        && !$variation->get('field_stock_quantity')->isEmpty()) {
      $qty = (int) $variation->get('field_stock_quantity')->value;
      if ($qty > 0) {
        return TRUE;
      }
    }
  }

  // Si alguna variación tenía el campo pero todas con stock 0, está agotado.
  if (!empty($variations)) {
    $firstVariation = reset($variations);
    if ($firstVariation->hasField('field_stock_quantity')) {
      return FALSE;
    }
  }

  // 3. field_stock_quantity en el producto directamente.
  if ($product->hasField('field_stock_quantity')
      && !$product->get('field_stock_quantity')->isEmpty()) {
    return (int) $product->get('field_stock_quantity')->value > 0;
  }

  // 4. Sin gestión de stock: asumir disponible si el producto está publicado.
  return $product->isPublished();
}

