<?php

declare(strict_types=1);

namespace Drupal\jaraba_site_builder\Service;

use Drupal\Core\Database\Connection;
use Drupal\Core\Entity\EntityTypeManagerInterface;
use Psr\Log\LoggerInterface;

/**
 * Servicio para gestión de redirects.
 *
 * Operaciones:
 * - Crear redirects manuales y automáticos
 * - Tracking de hits
 * - Resolución de redirects en request
 */
class RedirectService
{

    /**
     * Constructor.
     */
    public function __construct(
        protected EntityTypeManagerInterface $entityTypeManager,
        protected Connection $database,
        protected LoggerInterface $logger,
    ) {
    }

    /**
     * Crea un nuevo redirect.
     *
     * @param string $source
     *   URL de origen (sin dominio).
     * @param string $destination
     *   URL de destino.
     * @param int $tenantId
     *   ID del tenant.
     * @param int $type
     *   Código HTTP: 301, 302, 307.
     * @param string $reason
     *   Motivo del redirect.
     * @param bool $isAutoGenerated
     *   Si fue generado automáticamente.
     *
     * @return int
     *   ID del redirect creado.
     */
    public function create(
        string $source,
        string $destination,
        int $tenantId,
        int $type = 301,
        string $reason = '',
        bool $isAutoGenerated = FALSE,
    ): int {
        // Normalizar paths.
        $source = $this->normalizePath($source);
        $destination = $this->normalizePath($destination);

        // Verificar que no existe ya un redirect para este source.
        $existing = $this->findBySource($source, $tenantId);
        if ($existing) {
            // Actualizar el destino.
            $existing->set('destination_path', $destination);
            $existing->set('redirect_type', (string) $type);
            $existing->set('reason', $reason);
            $existing->set('is_auto_generated', $isAutoGenerated);
            $existing->save();

            $this->logger->info('Redirect actualizado: @source -> @dest', [
                '@source' => $source,
                '@dest' => $destination,
            ]);

            return (int) $existing->id();
        }

        $storage = $this->entityTypeManager->getStorage('site_redirect');
        $entity = $storage->create([
            'tenant_id' => $tenantId,
            'source_path' => $source,
            'destination_path' => $destination,
            'redirect_type' => (string) $type,
            'reason' => $reason,
            'is_active' => TRUE,
            'is_auto_generated' => $isAutoGenerated,
        ]);

        $entity->save();

        $this->logger->info('Redirect creado: @source -> @dest (@type)', [
            '@source' => $source,
            '@dest' => $destination,
            '@type' => $type,
        ]);

        return (int) $entity->id();
    }

    /**
     * Crea un redirect automático cuando cambia una URL.
     *
     * Este método es llamado desde hook_entity_update().
     */
    public function createAutoRedirect(string $oldPath, string $newPath, int $tenantId): int
    {
        return $this->create(
            $oldPath,
            $newPath,
            $tenantId,
            301,
            'Auto-generated: URL changed',
            TRUE
        );
    }

    /**
     * Busca un redirect por URL de origen.
     *
     * @param string $source
     *   URL de origen.
     * @param int|null $tenantId
     *   ID del tenant (opcional).
     *
     * @return object|null
     *   Entidad redirect o NULL.
     */
    public function findBySource(string $source, ?int $tenantId = NULL): ?object
    {
        $source = $this->normalizePath($source);

        $properties = ['source_path' => $source];
        if ($tenantId !== NULL) {
            $properties['tenant_id'] = $tenantId;
        }

        $storage = $this->entityTypeManager->getStorage('site_redirect');
        $entities = $storage->loadByProperties($properties);

        return reset($entities) ?: NULL;
    }

    /**
     * Resuelve un redirect para una ruta.
     *
     * @param string $path
     *   Ruta solicitada.
     * @param int|null $tenantId
     *   ID del tenant.
     *
     * @return array|null
     *   Array con 'destination' y 'code', o NULL si no hay redirect.
     */
    public function resolve(string $path, ?int $tenantId = NULL): ?array
    {
        $redirect = $this->findBySource($path, $tenantId);

        if (!$redirect || !$redirect->isActive()) {
            return NULL;
        }

        // Registrar hit.
        $this->trackHit((int) $redirect->id());

        return [
            'destination' => $redirect->get('destination_path')->value,
            'code' => $redirect->getRedirectCode(),
        ];
    }

    /**
     * Registra un hit en un redirect.
     */
    public function trackHit(int $redirectId): void
    {
        $this->database->update('site_redirect')
            ->expression('hit_count', 'hit_count + 1')
            ->condition('id', $redirectId)
            ->execute();

        $this->database->update('site_redirect')
            ->fields(['last_hit' => \Drupal::time()->getRequestTime()])
            ->condition('id', $redirectId)
            ->execute();
    }

    /**
     * Normaliza un path.
     */
    protected function normalizePath(string $path): string
    {
        // Asegurar que empiece con /.
        if (!str_starts_with($path, '/') && !str_starts_with($path, 'http')) {
            $path = '/' . $path;
        }

        // Eliminar trailing slash excepto para root.
        if ($path !== '/' && str_ends_with($path, '/')) {
            $path = rtrim($path, '/');
        }

        return $path;
    }

    /**
     * Obtiene estadísticas de redirects para un tenant.
     */
    public function getStats(int $tenantId): array
    {
        $storage = $this->entityTypeManager->getStorage('site_redirect');

        // Total de redirects.
        $totalQuery = $storage->getQuery()
            ->condition('tenant_id', $tenantId)
            ->accessCheck(FALSE)
            ->count();
        $total = (int) $totalQuery->execute();

        // Redirects activos.
        $activeQuery = $storage->getQuery()
            ->condition('tenant_id', $tenantId)
            ->condition('is_active', TRUE)
            ->accessCheck(FALSE)
            ->count();
        $active = (int) $activeQuery->execute();

        // Auto-generados.
        $autoQuery = $storage->getQuery()
            ->condition('tenant_id', $tenantId)
            ->condition('is_auto_generated', TRUE)
            ->accessCheck(FALSE)
            ->count();
        $autoGenerated = (int) $autoQuery->execute();

        // Total de hits.
        $hitsQuery = $this->database->select('site_redirect', 'r')
            ->condition('r.tenant_id', $tenantId);
        $hitsQuery->addExpression('SUM(hit_count)', 'total_hits');
        $totalHits = (int) $hitsQuery->execute()->fetchField();

        return [
            'total' => $total,
            'active' => $active,
            'auto_generated' => $autoGenerated,
            'total_hits' => $totalHits,
        ];
    }

    /**
     * Obtiene los redirects más usados.
     *
     * @param int $tenantId
     *   ID del tenant.
     * @param int $limit
     *   Número de resultados.
     *
     * @return array
     *   Lista de redirects ordenados por hits.
     */
    public function getTopRedirects(int $tenantId, int $limit = 10): array
    {
        $query = $this->database->select('site_redirect', 'r')
            ->fields('r', [
                'id',
                'source_path',
                'destination_path',
                'redirect_type',
                'hit_count',
                'last_hit',
            ])
            ->condition('r.tenant_id', $tenantId)
            ->condition('r.is_active', TRUE)
            ->orderBy('r.hit_count', 'DESC')
            ->range(0, $limit);

        return $query->execute()->fetchAllAssoc('id', \PDO::FETCH_ASSOC) ?: [];
    }

    /**
     * Elimina redirects expirados.
     *
     * @return int
     *   Número de redirects eliminados.
     */
    public function cleanupExpired(): int
    {
        $now = \Drupal::time()->getRequestTime();

        $deleted = $this->database->delete('site_redirect')
            ->condition('expires_at', $now, '<')
            ->isNotNull('expires_at')
            ->execute();

        if ($deleted > 0) {
            $this->logger->info('Eliminados @count redirects expirados.', ['@count' => $deleted]);
        }

        return $deleted;
    }

}
