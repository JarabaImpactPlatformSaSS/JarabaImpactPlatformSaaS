<?php

/**
 * @file
 * MÃ³dulo principal de Jaraba Credentials.
 *
 * Sistema de credenciales digitales basado en Open Badge 3.0.
 * Implementa verificaciÃ³n criptogrÃ¡fica Ed25519 y emisiÃ³n automÃ¡tica.
 */

declare(strict_types=1);

use Drupal\Core\Entity\EntityInterface;

/**
 * Implements hook_theme().
 */
function jaraba_credentials_theme(): array {
  return [
    'credential_verify' => [
      'variables' => [
        'credential' => NULL,
        'issuer' => NULL,
        'template' => NULL,
        'is_valid' => FALSE,
        'verification_message' => '',
        'qr_code' => '',
      ],
      'template' => 'credential-verify',
    ],
    'credential_card' => [
      'variables' => [
        'credential' => NULL,
        'template' => NULL,
        'show_actions' => TRUE,
      ],
      'template' => 'credential-card',
    ],
    'credentials_dashboard' => [
      'variables' => [
        'credentials' => [],
        'user' => NULL,
        'total_count' => 0,
      ],
      'template' => 'credentials-dashboard',
    ],
    'revocation_entry' => [
      'variables' => [
        'entry' => NULL,
        'credential' => NULL,
        'revoked_by' => NULL,
      ],
      'template' => 'revocation-entry',
    ],
    'stack_progress_card' => [
      'variables' => [
        'stack' => NULL,
        'progress_percent' => 0,
        'completed_templates' => [],
        'total_required' => 0,
        'status' => 'not_started',
      ],
      'template' => 'stack-progress-card',
    ],
  ];
}

/**
 * Implements hook_entity_insert().
 *
 * ECA-TRAIN-003: EmisiÃ³n automÃ¡tica de badge al crear certificaciÃ³n.
 * ECA-CRED-001: GeneraciÃ³n automÃ¡tica de PDF al crear credencial.
 * GAP-3: EmisiÃ³n automÃ¡tica al aprobar examen interactivo.
 */
function jaraba_credentials_entity_insert(EntityInterface $entity): void {
  if ($entity->getEntityTypeId() === 'user_certification') {
    _jaraba_credentials_auto_emit_badge($entity);
  }

  // Generar PDF automÃ¡ticamente cuando se crea una credencial.
  if ($entity->getEntityTypeId() === 'issued_credential') {
    _jaraba_credentials_generate_pdf($entity);
    _jaraba_credentials_evaluate_stacks($entity);
  }

  // GAP-3: Emitir credencial al aprobar examen interactivo.
  if ($entity->getEntityTypeId() === 'interactive_result') {
    _jaraba_credentials_process_interactive_result($entity);
  }
}

/**
 * Implements hook_entity_update().
 *
 * P1-04: Trigger de credencial cuando una certificacion cambia de estado.
 * Complementa hook_entity_insert: si la certificacion se creo sin estado
 * 'active' y luego se actualiza a 'active', se emite el badge igualmente.
 */
function jaraba_credentials_entity_update(EntityInterface $entity): void {
  if ($entity->getEntityTypeId() === 'user_certification') {
    _jaraba_credentials_handle_certification_update($entity);
  }
}

/**
 * Procesa actualizacion de certificacion para emision de credencial.
 *
 * P1-04: Si una certificacion transiciona a 'active' (desde cualquier
 * estado previo distinto), se emite automaticamente el badge asociado.
 * Esto cubre escenarios donde la certificacion se crea en estado pendiente
 * y luego es aprobada por un administrador o proceso asincrono.
 *
 * @param \Drupal\Core\Entity\EntityInterface $certification
 *   La entidad UserCertification actualizada.
 */
function _jaraba_credentials_handle_certification_update(EntityInterface $certification): void {
  $currentStatus = $certification->get('certification_status')->value ?? '';
  $original = $certification->original ?? NULL;
  $previousStatus = $original ? ($original->get('certification_status')->value ?? '') : '';

  // Solo actuar si acaba de transicionar a 'active'.
  if ($currentStatus !== 'active' || $previousStatus === 'active') {
    return;
  }

  _jaraba_credentials_auto_emit_badge($certification);
}

/**
 * Procesa resultado de contenido interactivo para emisiÃ³n de credencial.
 *
 * GAP-3: Cuando un usuario aprueba un examen/quiz vinculado a un
 * CredentialTemplate, se emite automÃ¡ticamente una IssuedCredential.
 *
 * @param \Drupal\Core\Entity\EntityInterface $result
 *   La entidad InteractiveResult reciÃ©n creada.
 */
function _jaraba_credentials_process_interactive_result(EntityInterface $result): void {
  // Verificar si el resultado es aprobado.
  $passed = (bool) ($result->get('passed')->value ?? FALSE);
  if (!$passed) {
    return;
  }

  try {
    /** @var \Drupal\jaraba_credentials\Service\LmsCredentialsIntegration $integration */
    $integration = \Drupal::service('jaraba_credentials.lms_integration');
    $credential = $integration->issueForInteractiveResult($result);

    if ($credential) {
      \Drupal::logger('jaraba_credentials')->info(
        'ðŸŽ“ Credential auto-issued from exam: @uuid for user @user',
        [
          '@uuid' => $credential->uuid(),
          '@user' => $result->get('uid')->target_id ?? 'unknown',
        ]
      );
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'ðŸš« Error in interactive result credential issuance: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

/**
 * Genera PDF para una credencial reciÃ©n creada.
 *
 * @param \Drupal\Core\Entity\EntityInterface $credential
 *   La entidad IssuedCredential reciÃ©n creada.
 */
function _jaraba_credentials_generate_pdf(EntityInterface $credential): void {
  // Solo generar si no tiene PDF adjunto.
  if (!$credential->get('pdf_file')->isEmpty()) {
    return;
  }

  try {
    /** @var \Drupal\jaraba_credentials\Service\CredentialPdfService $pdfService */
    $pdfService = \Drupal::service('jaraba_credentials.pdf_generator');
    
    // Generar PDF.
    $pdfUri = $pdfService->generatePdf($credential);
    
    if ($pdfUri) {
      // Crear entidad de archivo para el PDF.
      /** @var \Drupal\file\FileStorageInterface $fileStorage */
      $fileStorage = \Drupal::entityTypeManager()->getStorage('file');
      
      $file = $fileStorage->create([
        'uri' => $pdfUri,
        'uid' => $credential->getOwnerId() ?? 1,
        'status' => 1,
        'filename' => basename($pdfUri),
      ]);
      $file->save();
      
      // Adjuntar el archivo a la credencial.
      $credential->set('pdf_file', $file->id());
      
      // Guardar sin disparar hooks de nuevo (evita recursiÃ³n).
      $credential->original = $credential;
      $credential->save();
      
      \Drupal::logger('jaraba_credentials')->info(
        'âœ… PDF generado para credencial @uuid',
        ['@uuid' => $credential->uuid()]
      );
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'ðŸš« Error generando PDF: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

/**
 * Emite automÃ¡ticamente un badge cuando se crea una certificaciÃ³n.
 *
 * @param \Drupal\Core\Entity\EntityInterface $certification
 *   La entidad UserCertification reciÃ©n creada.
 */
function _jaraba_credentials_auto_emit_badge(EntityInterface $certification): void {
  // Solo emitir si el estado es 'active'.
  $status = $certification->get('certification_status')->value ?? '';
  if ($status !== 'active') {
    return;
  }

  try {
    /** @var \Drupal\jaraba_credentials\Service\CredentialIssuer $issuer */
    $issuer = \Drupal::service('jaraba_credentials.issuer');

    // Buscar template asociado al programa de certificacion.
    $programId = $certification->get('program_id')->target_id ?? NULL;
    if (!$programId) {
      return;
    }

    $template = $issuer->findTemplateForProgram($programId);
    if (!$template) {
      \Drupal::logger('jaraba_credentials')->warning(
        'No credential template found for program @program',
        ['@program' => $programId]
      );
      return;
    }

    // Emitir credencial con verificacion de limite del plan (P1-02).
    $userId = $certification->get('user_id')->target_id ?? NULL;
    if ($userId) {
      // Verificar limite mensual del plan antes de emitir.
      $limitResult = _jaraba_credentials_check_issuance_limit($userId);
      if (!$limitResult['allowed']) {
        \Drupal::logger('jaraba_credentials')->warning(
          'Credential issuance blocked by plan limit for user @user: @reason',
          ['@user' => $userId, '@reason' => $limitResult['reason']]
        );
        return;
      }

      $issuer->issueCredential($template, $userId, [
        'trigger' => 'certification',
        'certification_id' => $certification->id(),
        'exam_score' => $certification->get('exam_score')->value ?? NULL,
      ]);

      \Drupal::logger('jaraba_credentials')->info(
        'Auto-emitted badge for user @user from certification @cert',
        ['@user' => $userId, '@cert' => $certification->id()]
      );
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'Failed to auto-emit badge: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

/**
 * Verifica si la emision de credenciales esta permitida por el plan del tenant.
 *
 * PROPOSITO:
 * Consulta PlanValidator (si disponible) para verificar que el tenant
 * del usuario no ha excedido su limite mensual de credenciales.
 * Se utiliza como guardian antes de cualquier emision automatica.
 *
 * LOGICA:
 * 1. Resuelve el tenant del usuario via grupo/membership
 * 2. Cuenta credenciales emitidas este mes para el tenant
 * 3. Delega validacion a PlanValidator::enforceLimit('issue_credential')
 * 4. Si PlanValidator no esta disponible, permite la emision (fallback)
 *
 * LIMITES POR DEFECTO (configurables via SaasPlan Content Entity):
 * - Starter: 10 credenciales/mes
 * - Professional: 100 credenciales/mes
 * - Enterprise: ilimitado (-1)
 *
 * @param int $user_id
 *   ID del usuario destinatario de la credencial.
 *
 * @return array
 *   Array con 'allowed' (bool) y 'reason' (string si denegado).
 *
 * @see \Drupal\jaraba_billing\Service\PlanValidator::canIssueCredential()
 */
function _jaraba_credentials_check_issuance_limit(int $user_id): array {
  // Verificar si PlanValidator esta disponible.
  if (!\Drupal::hasService('jaraba_billing.plan_validator')) {
    return ['allowed' => TRUE, 'reason' => NULL];
  }

  try {
    // Resolver el tenant del usuario via membership de grupo.
    $user = \Drupal::entityTypeManager()->getStorage('user')->load($user_id);
    if (!$user) {
      return ['allowed' => TRUE, 'reason' => NULL];
    }

    // Intentar obtener el tenant del usuario via campo field_tenant
    // o via memberships de grupo.
    $tenant = NULL;
    if ($user->hasField('field_tenant') && !$user->get('field_tenant')->isEmpty()) {
      $tenant = $user->get('field_tenant')->entity;
    }
    elseif (\Drupal::hasService('group.membership_loader')) {
      $membershipLoader = \Drupal::service('group.membership_loader');
      $memberships = $membershipLoader->loadByUser($user);
      if (!empty($memberships)) {
        $firstMembership = reset($memberships);
        if ($firstMembership instanceof \Drupal\group\Entity\GroupRelationshipInterface) {
          $tenant = $firstMembership->getGroup();
        }
      }
    }

    if (!$tenant || !($tenant instanceof \Drupal\ecosistema_jaraba_core\Entity\TenantInterface)) {
      // Sin tenant resuelto, permitir emision (fallback seguro).
      return ['allowed' => TRUE, 'reason' => NULL];
    }

    // Contar credenciales emitidas este mes para este tenant.
    $monthStart = date('Y-m-01');
    $monthEnd = date('Y-m-t');

    $monthlyCount = (int) \Drupal::entityTypeManager()
      ->getStorage('issued_credential')
      ->getQuery()
      ->accessCheck(FALSE)
      ->condition('tenant_id', $tenant->id())
      ->condition('issued_on', $monthStart, '>=')
      ->condition('issued_on', $monthEnd . ' 23:59:59', '<=')
      ->count()
      ->execute();

    // Validar contra el plan via PlanValidator centralizado.
    /** @var \Drupal\jaraba_billing\Service\PlanValidator $planValidator */
    $planValidator = \Drupal::service('jaraba_billing.plan_validator');

    return $planValidator->enforceLimit($tenant, 'issue_credential', [
      'current' => $monthlyCount,
    ]);
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'Error checking issuance limit for user @user: @message',
      ['@user' => $user_id, '@message' => $e->getMessage()]
    );
    // En caso de error, permitir emision para no bloquear el flujo.
    return ['allowed' => TRUE, 'reason' => NULL];
  }
}

/**
 * Implements hook_ENTITY_TYPE_update() for lms_enrollment.
 *
 * ECA-TRAIN-003: EmisiÃ³n automÃ¡tica de credencial al completar curso LMS.
 * 
 * Este hook se dispara cuando un enrollment cambia de estado. Si pasa
 * a 'completed', se busca un CredentialTemplate asociado y se emite
 * automÃ¡ticamente una IssuedCredential firmada Ed25519.
 *
 * @see Drupal\jaraba_credentials\Service\LmsCredentialsIntegration
 */
function jaraba_credentials_lms_enrollment_update(EntityInterface $entity): void {
  // Solo procesar si el mÃ³dulo jaraba_lms estÃ¡ instalado
  if (!interface_exists('Drupal\jaraba_lms\Entity\EnrollmentInterface')) {
    return;
  }

  // Verificar que es un lms_enrollment
  if ($entity->getEntityTypeId() !== 'lms_enrollment') {
    return;
  }

  // Obtener estado anterior y actual
  /** @var \Drupal\Core\Entity\ContentEntityInterface $original */
  $original = $entity->original ?? NULL;
  $currentStatus = $entity->get('status')->value ?? '';
  $previousStatus = $original ? ($original->get('status')->value ?? '') : '';

  // Solo actuar si acaba de pasar a 'completed'
  if ($currentStatus !== 'completed' || $previousStatus === 'completed') {
    return;
  }

  \Drupal::logger('jaraba_credentials')->info(
    'LMS enrollment @id completed, checking for auto-credential issuance',
    ['@id' => $entity->id()]
  );

  // P1-02: Verificar limite mensual del plan antes de emitir.
  $userId = (int) ($entity->get('uid')->target_id ?? $entity->getOwnerId() ?? 0);
  if ($userId) {
    $limitResult = _jaraba_credentials_check_issuance_limit($userId);
    if (!$limitResult['allowed']) {
      \Drupal::logger('jaraba_credentials')->warning(
        'LMS credential issuance blocked by plan limit for user @user: @reason',
        ['@user' => $userId, '@reason' => $limitResult['reason']]
      );
      return;
    }
  }

  try {
    /** @var \Drupal\jaraba_credentials\Service\LmsCredentialsIntegration $integration */
    $integration = \Drupal::service('jaraba_credentials.lms_integration');
    $integration->issueForCourseCompletion($entity);
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'Error in LMS credential integration: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

/**
 * Implements hook_cron().
 *
 * ECA-TRAIN-001/002: Tareas programadas de credenciales.
 * - Enviar recordatorios de expiraciÃ³n
 * - Procesar cola de notificaciones
 */
function jaraba_credentials_cron(): void {
  _jaraba_credentials_process_expiration_reminders();
  _jaraba_credentials_process_notification_queue();
}

/**
 * Procesa recordatorios de expiraciÃ³n de credenciales.
 *
 * EnvÃ­a notificaciones a usuarios cuyas credenciales expiran en 30 dÃ­as.
 */
function _jaraba_credentials_process_expiration_reminders(): void {
  $threshold = strtotime('+30 days');
  $now = \Drupal::time()->getRequestTime();

  $storage = \Drupal::entityTypeManager()->getStorage('issued_credential');
  $query = $storage->getQuery()
    ->accessCheck(FALSE)
    ->condition('status', 'issued')
    ->condition('expires_on', $now, '>')
    ->condition('expires_on', $threshold, '<')
    ->range(0, 50);

  $ids = $query->execute();
  if (empty($ids)) {
    return;
  }

  $queue = \Drupal::queue('jaraba_credentials_notifications');
  foreach ($ids as $id) {
    $credential = $storage->load($id);
    if (!$credential) {
      continue;
    }

    // Verificar que no se ha enviado ya recordatorio
    $metadata = json_decode($credential->get('metadata')->value ?? '{}', TRUE);
    if (!empty($metadata['expiration_reminder_sent'])) {
      continue;
    }

    $queue->createItem([
      'type' => 'expiration_reminder',
      'credential_id' => $id,
      'user_id' => $credential->get('recipient_id')->target_id,
    ]);
  }
}

/**
 * Procesa la cola de notificaciones de credenciales.
 */
function _jaraba_credentials_process_notification_queue(): void {
  $queue = \Drupal::queue('jaraba_credentials_notifications');
  $processed = 0;
  $maxItems = 10;

  while ($processed < $maxItems && ($item = $queue->claimItem())) {
    try {
      $data = $item->data;

      // Send email notification via mail manager.
      $userId = $data['user_id'] ?? NULL;
      if ($userId) {
        $user = \Drupal::entityTypeManager()->getStorage('user')->load($userId);
        if ($user && $user->getEmail()) {
          $mailKey = match ($data['type'] ?? 'generic') {
            'credential_issued' => 'credential_issued',
            'credential_expiring' => 'credential_expiring',
            'credential_revoked' => 'credential_revoked',
            default => 'credential_notification',
          };
          \Drupal::service('plugin.manager.mail')->mail(
            'jaraba_credentials',
            $mailKey,
            $user->getEmail(),
            $user->getPreferredLangcode(),
            array_merge($data, ['user_name' => $user->getDisplayName()])
          );
        }
      }

      \Drupal::logger('jaraba_credentials')->debug(
        'Processing notification: @type for user @user',
        ['@type' => $data['type'], '@user' => $data['user_id'] ?? 'unknown']
      );
      $queue->deleteItem($item);
      $processed++;
    }
    catch (\Exception $e) {
      \Drupal::logger('jaraba_credentials')->error(
        'Failed to process notification: @message',
        ['@message' => $e->getMessage()]
      );
      $queue->releaseItem($item);
    }
  }
}

/**
 * Implements hook_mail().
 */
function jaraba_credentials_mail($key, &$message, $params): void {
  switch ($key) {
    case 'credential_issued':
      $message['subject'] = t('Nueva credencial emitida: @credential', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
      ]);
      $message['body'][] = t('Hola @name,', ['@name' => $params['user_name']]);
      $message['body'][] = t('Se te ha emitido la credencial "@credential".', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
      ]);
      $message['body'][] = t('Puedes consultarla y compartirla desde tu perfil de credenciales.');
      break;

    case 'credential_expiring':
      $message['subject'] = t('Tu credencial expira pronto: @credential', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
      ]);
      $message['body'][] = t('Hola @name,', ['@name' => $params['user_name']]);
      $message['body'][] = t('Tu credencial "@credential" expira el @date.', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
        '@date' => $params['expiration_date'] ?? '',
      ]);
      $message['body'][] = t('Contacta con tu organizaciÃ³n para renovarla a tiempo.');
      break;

    case 'credential_revoked':
      $message['subject'] = t('Credencial revocada: @credential', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
      ]);
      $message['body'][] = t('Hola @name,', ['@name' => $params['user_name']]);
      $message['body'][] = t('Tu credencial "@credential" ha sido revocada.', [
        '@credential' => $params['credential_name'] ?? 'Credencial',
      ]);
      if (!empty($params['reason'])) {
        $message['body'][] = t('Motivo: @reason', ['@reason' => $params['reason']]);
      }
      break;

    case 'credential_notification':
      $message['subject'] = t('NotificaciÃ³n de credenciales');
      $message['body'][] = t('Hola @name,', ['@name' => $params['user_name']]);
      $message['body'][] = t('Tienes una actualizaciÃ³n en tus credenciales digitales.');
      break;
  }

  // Footer comÃºn.
  if (!empty($message['body'])) {
    $message['body'][] = '';
    $message['body'][] = '---';
    $message['body'][] = t('Jaraba Impact Platform - Credenciales Digitales');
  }
}

/**
 * Implements hook_theme_suggestions_page_alter().
 *
 * AÃ±ade template page--verify para la pÃ¡gina pÃºblica de verificaciÃ³n.
 * Usa layout premium con partÃ­culas animadas y diseÃ±o full-width.
 *
 * @see page--verify.html.twig
 */
function jaraba_credentials_theme_suggestions_page_alter(array &$suggestions, array $variables): void {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();

  // PÃ¡gina pÃºblica de verificaciÃ³n de credenciales.
  if ($route_name === 'jaraba_credentials.verify') {
    $suggestions[] = 'page__verify';
  }
}

/**
 * Implements hook_preprocess_html().
 *
 * AÃ±ade clases al body para la pÃ¡gina de verificaciÃ³n.
 * NOTA: Las clases al body DEBEN aÃ±adirse via hook_preprocess_html(),
 * no con attributes.addClass() en templates (problema D11).
 */
function jaraba_credentials_preprocess_html(array &$variables): void {
  $route_match = \Drupal::routeMatch();
  $route_name = $route_match->getRouteName();

  // PÃ¡gina de verificaciÃ³n de credenciales.
  if ($route_name === 'jaraba_credentials.verify') {
    $variables['attributes']['class'][] = 'page-verify';
    $variables['attributes']['class'][] = 'credential-verify-page';
  }

  // Dashboard de certificaciones del usuario.
  if ($route_name === 'jaraba_credentials.my_credentials') {
    $variables['attributes']['class'][] = 'certifications-page';
    $variables['attributes']['class'][] = 'page-my-certifications';
  }
}

/**
 * EvalÃºa stacks de credenciales al emitir una nueva credencial.
 *
 * Hook nativo ECA: Cuando se emite una credencial, verifica si el usuario
 * ha completado algÃºn stack y auto-emite la credencial de stack.
 *
 * @param \Drupal\Core\Entity\EntityInterface $credential
 *   La entidad IssuedCredential reciÃ©n creada.
 */
function _jaraba_credentials_evaluate_stacks(EntityInterface $credential): void {
  // Evitar recursiÃ³n si esta credencial es resultado de un stack.
  $evidence = $credential->get('evidence')->value ?? '';
  if ($evidence && str_contains($evidence, '"stack_id"')) {
    return;
  }

  $templateId = $credential->get('template_id')->target_id ?? NULL;
  $recipientId = $credential->get('recipient_id')->target_id ?? NULL;

  if (!$templateId || !$recipientId) {
    return;
  }

  try {
    /** @var \Drupal\jaraba_credentials\Service\StackEvaluationService $evaluator */
    $evaluator = \Drupal::service('jaraba_credentials.stack_evaluation');
    $completedStacks = $evaluator->evaluateForUser((int) $recipientId, (int) $templateId);

    foreach ($completedStacks as $item) {
      \Drupal::logger('jaraba_credentials')->info(
        'Stack @stack auto-completado para usuario #@uid',
        [
          '@stack' => $item['stack']->get('name')->value,
          '@uid' => $recipientId,
        ]
      );
    }

    // Actualizar progreso de stacks no completados.
    /** @var \Drupal\jaraba_credentials\Service\StackProgressTracker $tracker */
    $tracker = \Drupal::service('jaraba_credentials.stack_progress');
    $stackIds = \Drupal::entityTypeManager()->getStorage('credential_stack')
      ->getQuery()
      ->accessCheck(FALSE)
      ->condition('status', TRUE)
      ->execute();

    $userTemplateIds = _jaraba_credentials_get_user_template_ids((int) $recipientId);

    foreach ($stackIds as $stackId) {
      $stack = \Drupal::entityTypeManager()->getStorage('credential_stack')->load($stackId);
      if (!$stack) {
        continue;
      }
      $requiredIds = $stack->getRequiredTemplateIds();
      if (in_array((int) $templateId, $requiredIds, TRUE) ||
          in_array((int) $templateId, $stack->getOptionalTemplateIds(), TRUE)) {
        $tracker->updateProgress($stack, (int) $recipientId, $userTemplateIds);
      }
    }
  }
  catch (\Exception $e) {
    \Drupal::logger('jaraba_credentials')->error(
      'Error evaluando stacks: @message',
      ['@message' => $e->getMessage()]
    );
  }
}

/**
 * Obtiene los template IDs de credenciales activas de un usuario.
 */
function _jaraba_credentials_get_user_template_ids(int $uid): array {
  $ids = \Drupal::entityTypeManager()->getStorage('issued_credential')
    ->getQuery()
    ->accessCheck(FALSE)
    ->condition('recipient_id', $uid)
    ->condition('status', 'active')
    ->execute();

  if (empty($ids)) {
    return [];
  }

  $credentials = \Drupal::entityTypeManager()->getStorage('issued_credential')->loadMultiple($ids);
  $templateIds = [];
  foreach ($credentials as $credential) {
    $tid = $credential->get('template_id')->target_id ?? NULL;
    if ($tid) {
      $templateIds[] = (int) $tid;
    }
  }

  return array_unique($templateIds);
}

